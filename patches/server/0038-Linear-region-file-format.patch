From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: GideonWhite1029 <gideonwhite1029@gmail.com>
Date: Mon, 9 Sep 2024 23:51:33 +0300
Subject: [PATCH] Linear region file format


diff --git a/build.gradle.kts b/build.gradle.kts
index 44a86ae663fa94ea76aab348f52064ee8f35be6b..7367bd9423f69e5f7d42745e9fa5733623ee3c58 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -30,6 +30,10 @@ dependencies {
     alsoShade(log4jPlugins.output)
     implementation("io.netty:netty-codec-haproxy:4.1.97.Final") // Paper - Add support for proxy protocol
     // Paper end
+    // Horizon start - Linear format
+    implementation("com.github.luben:zstd-jni:1.5.6-3")
+    implementation("org.lz4:lz4-java:1.8.0")
+    // Horizon end - Linear format
     implementation("org.apache.logging.log4j:log4j-iostreams:2.22.1") // Paper - remove exclusion
     implementation("org.ow2.asm:asm-commons:9.7.1")
     implementation("org.spongepowered:configurate-yaml:4.2.0-SNAPSHOT") // Paper - config files
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/io/ChunkSystemRegionFileStorage.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/io/ChunkSystemRegionFileStorage.java
index 73df26b27146bbad2106d57b22dd3c792ed3dd1d..7c4c0cf4e2b26f3efba4d9f7f92a705137b87e72 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/io/ChunkSystemRegionFileStorage.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/io/ChunkSystemRegionFileStorage.java
@@ -7,8 +7,8 @@ public interface ChunkSystemRegionFileStorage {
 
     public boolean moonrise$doesRegionFileNotExistNoIO(final int chunkX, final int chunkZ);
 
-    public RegionFile moonrise$getRegionFileIfLoaded(final int chunkX, final int chunkZ);
+    public dev.horizonmc.horizon.region.AbstractRegionFile moonrise$getRegionFileIfLoaded(final int chunkX, final int chunkZ);
 
-    public RegionFile moonrise$getRegionFileIfExists(final int chunkX, final int chunkZ) throws IOException;
+    public dev.horizonmc.horizon.region.AbstractRegionFile moonrise$getRegionFileIfExists(final int chunkX, final int chunkZ) throws IOException;
 
 }
diff --git a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/io/RegionFileIOThread.java b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/io/RegionFileIOThread.java
index 3218cbf84f54daf06e84442d5eb1a36d8da6b215..dad73830f5361728fccdeedd9941c8b63835ed53 100644
--- a/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/io/RegionFileIOThread.java
+++ b/src/main/java/ca/spottedleaf/moonrise/patches/chunk_system/io/RegionFileIOThread.java
@@ -1043,9 +1043,9 @@ public final class RegionFileIOThread extends PrioritisedQueueExecutorThread {
             return ((ChunkSystemRegionFileStorage)(Object)this.getCache()).moonrise$doesRegionFileNotExistNoIO(chunkX, chunkZ);
         }
 
-        public <T> T computeForRegionFile(final int chunkX, final int chunkZ, final boolean existingOnly, final Function<RegionFile, T> function) {
+        public <T> T computeForRegionFile(final int chunkX, final int chunkZ, final boolean existingOnly, final Function<dev.horizonmc.horizon.region.AbstractRegionFile, T> function) { // Horizon
             final RegionFileStorage cache = this.getCache();
-            final RegionFile regionFile;
+            final dev.horizonmc.horizon.region.AbstractRegionFile regionFile; // Horizon
             synchronized (cache) {
                 try {
                     if (existingOnly) {
@@ -1061,9 +1061,9 @@ public final class RegionFileIOThread extends PrioritisedQueueExecutorThread {
             }
         }
 
-        public <T> T computeForRegionFileIfLoaded(final int chunkX, final int chunkZ, final Function<RegionFile, T> function) {
+        public <T> T computeForRegionFileIfLoaded(final int chunkX, final int chunkZ, final Function<dev.horizonmc.horizon.region.AbstractRegionFile, T> function) { // Horizon
             final RegionFileStorage cache = this.getCache();
-            final RegionFile regionFile;
+            final dev.horizonmc.horizon.region.AbstractRegionFile regionFile; // Horizon
 
             synchronized (cache) {
                 regionFile = ((ChunkSystemRegionFileStorage)(Object)cache).moonrise$getRegionFileIfLoaded(chunkX, chunkZ);
diff --git a/src/main/java/dev/horizonmc/horizon/HorizonConfig.java b/src/main/java/dev/horizonmc/horizon/HorizonConfig.java
index 18defab0bce5cf2d2f8e929dbd5881e33827e8c2..b45101b4f78db52425e169b9bf1bf7798568a108 100644
--- a/src/main/java/dev/horizonmc/horizon/HorizonConfig.java
+++ b/src/main/java/dev/horizonmc/horizon/HorizonConfig.java
@@ -243,4 +243,42 @@ public final class HorizonConfig {
     @GlobalConfig(name = "secure-seed", category = {"features"})
     public static boolean secureSeed = false;
 
+    // Horizon start - region
+    @GlobalConfig(name = "format", category = "region", lock = true, verify = RegionFormatVerify.class)
+    public static dev.horizonmc.horizon.region.RegionFileFormat regionFormat = dev.horizonmc.horizon.region.RegionFileFormat.ANVIL;
+
+    private static class RegionFormatVerify extends ConfigVerify.EnumConfigVerify<dev.horizonmc.horizon.region.RegionFileFormat> {
+    }
+
+    @GlobalConfig(name = "flush-frequency", category = {"region", "linear"}, lock = true, verify = ConfigVerify.IntConfigVerify.class)
+    public static int linearFlushFrequency = 10;
+
+    @GlobalConfig(name = "auto-convert-anvil-to-linear", category = {"region", "linear"}, lock = true)
+    public static boolean autoConvertAnvilToLinear = false;
+
+    @GlobalConfig(name = "flush-max-threads", category = {"region", "linear"}, lock = true, verify = ConfigVerify.IntConfigVerify.class)
+    public static int linearFlushThreads = 1;
+
+    public static int getLinearFlushThreads() {
+        if (linearFlushThreads < 0) {
+            return Math.max(Runtime.getRuntime().availableProcessors() + linearFlushThreads, 1);
+        } else {
+            return Math.max(linearFlushThreads, 1);
+        }
+    }
+
+    @GlobalConfig(name = "compression-level", category = {"region", "linear"}, lock = true, verify = LinearCompressVerify.class)
+    public static int linearCompressionLevel = 1;
+
+    private static class LinearCompressVerify extends ConfigVerify.IntConfigVerify {
+        @Override
+        public String check(Integer old, Integer value) throws IllegalArgumentException {
+            if (value < 1 || value > 22) {
+                throw new IllegalArgumentException("linear.compression-level need between 1 and 22");
+            }
+            return null;
+        }
+    }
+    // Horizon end - region
+
 }
\ No newline at end of file
diff --git a/src/main/java/dev/horizonmc/horizon/region/AbstractRegionFile.java b/src/main/java/dev/horizonmc/horizon/region/AbstractRegionFile.java
new file mode 100644
index 0000000000000000000000000000000000000000..296a70b5d7b6a831c3f5254f37411aba6e4e9094
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/region/AbstractRegionFile.java
@@ -0,0 +1,38 @@
+package dev.horizonmc.horizon.region;
+
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.chunk.status.ChunkStatus;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.nio.file.Path;
+import java.util.concurrent.locks.ReentrantLock;
+
+public interface AbstractRegionFile {
+
+    Path getPath();
+
+    DataInputStream getChunkDataInputStream(ChunkPos pos) throws IOException;
+
+    DataOutputStream getChunkDataOutputStream(ChunkPos pos) throws IOException;
+
+    CompoundTag getOversizedData(int x, int z) throws IOException;
+
+    boolean recalculateHeader() throws IOException ;
+
+    boolean hasChunk(ChunkPos pos);
+
+    boolean doesChunkExist(ChunkPos pos);
+
+    boolean isOversized(int x, int z);
+
+    void flush() throws IOException;
+
+    void close() throws IOException;
+
+    void clear(ChunkPos pos) throws IOException;
+
+    void setOversized(int x, int z, boolean oversized) throws IOException;
+}
diff --git a/src/main/java/dev/horizonmc/horizon/region/AbstractRegionFileFactory.java b/src/main/java/dev/horizonmc/horizon/region/AbstractRegionFileFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..a8676f59ae872c87dac3ad329bd7bb3db751ea12
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/region/AbstractRegionFileFactory.java
@@ -0,0 +1,24 @@
+package dev.horizonmc.horizon.region;
+
+import dev.horizonmc.horizon.HorizonConfig;
+import net.minecraft.world.level.chunk.storage.RegionFile;
+import net.minecraft.world.level.chunk.storage.RegionFileVersion;
+import net.minecraft.world.level.chunk.storage.RegionStorageInfo;
+
+import java.io.IOException;
+import java.nio.file.Path;
+
+public class AbstractRegionFileFactory {
+
+    public static AbstractRegionFile getAbstractRegionFile(RegionStorageInfo storageKey, Path directory, Path path, boolean dsync) throws IOException {
+        return getAbstractRegionFile(storageKey, directory, path, RegionFileVersion.getCompressionFormat(), dsync);
+    }
+
+    public static AbstractRegionFile getAbstractRegionFile(RegionStorageInfo storageKey, Path path, Path directory, RegionFileVersion compressionFormat, boolean dsync) throws IOException {
+        if (path.toString().endsWith(".linear")) {
+            return new LinearRegionFile(path, HorizonConfig.linearCompressionLevel);
+        } else {
+            return new RegionFile(storageKey, path, directory, compressionFormat, dsync);
+        }
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/region/LinearRegionFile.java b/src/main/java/dev/horizonmc/horizon/region/LinearRegionFile.java
new file mode 100644
index 0000000000000000000000000000000000000000..b1c96da242ab17a363ecac89a70b212a4fcf1b84
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/region/LinearRegionFile.java
@@ -0,0 +1,319 @@
+package dev.horizonmc.horizon.region;
+
+import com.github.luben.zstd.ZstdInputStream;
+import com.github.luben.zstd.ZstdOutputStream;
+import com.mojang.logging.LogUtils;
+
+import java.io.BufferedOutputStream;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.ByteBuffer;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.StandardCopyOption;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+import javax.annotation.Nullable;
+
+import net.jpountz.lz4.LZ4Compressor;
+import net.jpountz.lz4.LZ4Factory;
+import net.jpountz.lz4.LZ4FastDecompressor;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.world.level.ChunkPos;
+import org.slf4j.Logger;
+
+// Powered by LinearPurpur(https://github.com/StupidCraft/LinearPurpur)
+public class LinearRegionFile implements AbstractRegionFile, AutoCloseable {
+
+    private static final long SUPERBLOCK = -4323716122432332390L;
+    private static final byte VERSION = 2;
+    private static final int HEADER_SIZE = 32;
+    private static final int FOOTER_SIZE = 8;
+    private static final Logger LOGGER = LogUtils.getLogger();
+    private static final List<Byte> SUPPORTED_VERSIONS = Arrays.asList((byte) 1, (byte) 2);
+    private static final LinearRegionFileFlusher linearRegionFileFlusher = new LinearRegionFileFlusher();
+    private final byte[][] buffer = new byte[1024][];
+    private final int[] bufferUncompressedSize = new int[1024];
+    private final int[] chunkTimestamps = new int[1024];
+    private final LZ4Compressor compressor;
+    private final LZ4FastDecompressor decompressor;
+    private final int compressionLevel;
+    private final AtomicBoolean markedToSave = new AtomicBoolean(false);
+    public boolean closed = false;
+    public Path path;
+
+
+    public LinearRegionFile(Path file, int compression) throws IOException {
+        this.path = file;
+        this.compressionLevel = compression;
+        this.compressor = LZ4Factory.fastestInstance().fastCompressor();
+        this.decompressor = LZ4Factory.fastestInstance().fastDecompressor();
+
+        File regionFile = new File(this.path.toString());
+
+        Arrays.fill(this.bufferUncompressedSize, 0);
+
+        if (!regionFile.canRead()) {
+            return;
+        }
+
+        try (FileInputStream fileStream = new FileInputStream(regionFile);
+             DataInputStream rawDataStream = new DataInputStream(fileStream)) {
+
+            long superBlock = rawDataStream.readLong();
+            if (superBlock != SUPERBLOCK) {
+                throw new RuntimeException("Invalid superblock: " + superBlock + " in " + file);
+            }
+
+            byte version = rawDataStream.readByte();
+            if (!SUPPORTED_VERSIONS.contains(version)) {
+                throw new RuntimeException("Invalid version: " + version + " in " + file);
+            }
+
+            // Skip newestTimestamp (Long)  Compression level (Byte)  Chunk count (Short): Unused.
+            rawDataStream.skipBytes(11);
+
+            int dataCount = rawDataStream.readInt();
+            long fileLength = file.toFile().length();
+            if (fileLength != HEADER_SIZE + dataCount + FOOTER_SIZE) {
+                throw new IOException("Invalid file length: " + this.path + " " + fileLength + " " + (HEADER_SIZE + dataCount + FOOTER_SIZE));
+            }
+
+            rawDataStream.skipBytes(8); // Skip data hash (Long): Unused.
+
+            byte[] rawCompressed = new byte[dataCount];
+            rawDataStream.readFully(rawCompressed, 0, dataCount);
+
+            superBlock = rawDataStream.readLong();
+            if (superBlock != SUPERBLOCK) {
+                throw new IOException("Footer superblock invalid " + this.path);
+            }
+
+            try (DataInputStream dataStream = new DataInputStream(new ZstdInputStream(new ByteArrayInputStream(rawCompressed)))) {
+                int[] starts = new int[1024];
+                for (int i = 0; i < 1024; i++) {
+                    starts[i] = dataStream.readInt();
+                    dataStream.skipBytes(4); // Skip timestamps (Int): Unused.
+                }
+
+                for (int i = 0; i < 1024; i++) {
+                    if (starts[i] > 0) {
+                        int size = starts[i];
+                        byte[] b = new byte[size];
+                        dataStream.readFully(b, 0, size);
+
+                        int maxCompressedLength = this.compressor.maxCompressedLength(size);
+                        byte[] compressed = new byte[maxCompressedLength];
+                        int compressedLength = this.compressor.compress(b, 0, size, compressed, 0, maxCompressedLength);
+                        b = new byte[compressedLength];
+                        System.arraycopy(compressed, 0, b, 0, compressedLength);
+
+                        this.buffer[i] = b;
+                        this.bufferUncompressedSize[i] = size;
+                    }
+                }
+            }
+        }
+    }
+
+    private static int getChunkIndex(int x, int z) {
+        return (x & 31) + ((z & 31) << 5);
+    }
+
+    private static int getTimestamp() {
+        return (int) (System.currentTimeMillis() / 1000L);
+    }
+
+    public Path getPath() {
+        return this.path;
+    }
+
+    public void flush() throws IOException {
+        if (isMarkedToSave()) flushWrapper(); // sync
+    }
+
+    private void markToSave() {
+        linearRegionFileFlusher.scheduleSave(this);
+        markedToSave.set(true);
+    }
+
+    public boolean isMarkedToSave() {
+        return markedToSave.getAndSet(false);
+    }
+
+    public void flushWrapper() {
+        try {
+            save();
+        } catch (IOException e) {
+            LOGGER.error("Failed to flush region file {}", path.toAbsolutePath(), e);
+        }
+    }
+
+    public boolean doesChunkExist(ChunkPos pos) {
+        return false;
+    }
+
+    private synchronized void save() throws IOException {
+        long timestamp = getTimestamp();
+        short chunkCount = 0;
+
+        File tempFile = new File(path.toString() + ".tmp");
+
+        try (FileOutputStream fileStream = new FileOutputStream(tempFile);
+             ByteArrayOutputStream zstdByteArray = new ByteArrayOutputStream();
+             ZstdOutputStream zstdStream = new ZstdOutputStream(zstdByteArray, this.compressionLevel);
+             DataOutputStream zstdDataStream = new DataOutputStream(zstdStream);
+             DataOutputStream dataStream = new DataOutputStream(fileStream)) {
+
+            dataStream.writeLong(SUPERBLOCK);
+            dataStream.writeByte(VERSION);
+            dataStream.writeLong(timestamp);
+            dataStream.writeByte(this.compressionLevel);
+
+            ArrayList<byte[]> byteBuffers = new ArrayList<>();
+            for (int i = 0; i < 1024; i++) {
+                if (this.bufferUncompressedSize[i] != 0) {
+                    chunkCount = 1;
+                    byte[] content = new byte[bufferUncompressedSize[i]];
+                    this.decompressor.decompress(buffer[i], 0, content, 0, bufferUncompressedSize[i]);
+
+                    byteBuffers.add(content);
+                } else {
+                    byteBuffers.add(null);
+                }
+            }
+            for (int i = 0; i < 1024; i++) {
+                zstdDataStream.writeInt(this.bufferUncompressedSize[i]); // Write uncompressed size
+                zstdDataStream.writeInt(this.chunkTimestamps[i]); // Write timestamp
+            }
+            for (int i = 0; i < 1024; i++) {
+                if (byteBuffers.get(i) != null) {
+                    zstdDataStream.write(byteBuffers.get(i), 0, byteBuffers.get(i).length);
+                }
+            }
+            zstdDataStream.close();
+
+            dataStream.writeShort(chunkCount);
+
+            byte[] compressed = zstdByteArray.toByteArray();
+
+            dataStream.writeInt(compressed.length);
+            dataStream.writeLong(0);
+
+            dataStream.write(compressed, 0, compressed.length);
+            dataStream.writeLong(SUPERBLOCK);
+
+            dataStream.flush();
+            fileStream.getFD().sync();
+            fileStream.getChannel().force(true); // Ensure atomicity on Btrfs
+        }
+        Files.move(tempFile.toPath(), this.path, StandardCopyOption.REPLACE_EXISTING);
+    }
+
+    public synchronized void write(ChunkPos pos, ByteBuffer buffer) {
+        try {
+            byte[] b = toByteArray(new ByteArrayInputStream(buffer.array()));
+            int uncompressedSize = b.length;
+
+            int maxCompressedLength = this.compressor.maxCompressedLength(b.length);
+            byte[] compressed = new byte[maxCompressedLength];
+            int compressedLength = this.compressor.compress(b, 0, b.length, compressed, 0, maxCompressedLength);
+            b = new byte[compressedLength];
+            System.arraycopy(compressed, 0, b, 0, compressedLength);
+
+            int index = getChunkIndex(pos.x, pos.z);
+            this.buffer[index] = b;
+            this.chunkTimestamps[index] = getTimestamp();
+            this.bufferUncompressedSize[getChunkIndex(pos.x, pos.z)] = uncompressedSize;
+        } catch (IOException e) {
+            LOGGER.error("Chunk write IOException {} {}", e, this.path);
+        }
+        markToSave();
+    }
+
+    public DataOutputStream getChunkDataOutputStream(ChunkPos pos) {
+        return new DataOutputStream(new BufferedOutputStream(new ChunkBuffer(pos)));
+    }
+
+    private byte[] toByteArray(InputStream in) throws IOException {
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        byte[] tempBuffer = new byte[4096];
+
+        int length;
+        while ((length = in.read(tempBuffer)) >= 0) {
+            out.write(tempBuffer, 0, length);
+        }
+
+        return out.toByteArray();
+    }
+
+    @Nullable
+    public synchronized DataInputStream getChunkDataInputStream(ChunkPos pos) {
+        if (this.bufferUncompressedSize[getChunkIndex(pos.x, pos.z)] != 0) {
+            byte[] content = new byte[bufferUncompressedSize[getChunkIndex(pos.x, pos.z)]];
+            this.decompressor.decompress(this.buffer[getChunkIndex(pos.x, pos.z)], 0, content, 0, bufferUncompressedSize[getChunkIndex(pos.x, pos.z)]);
+            return new DataInputStream(new ByteArrayInputStream(content));
+        }
+        return null;
+    }
+
+    public void clear(ChunkPos pos) {
+        int i = getChunkIndex(pos.x, pos.z);
+        this.buffer[i] = null;
+        this.bufferUncompressedSize[i] = 0;
+        this.chunkTimestamps[i] = getTimestamp();
+        markToSave();
+    }
+
+    public boolean hasChunk(ChunkPos pos) {
+        return this.bufferUncompressedSize[getChunkIndex(pos.x, pos.z)] > 0;
+    }
+
+    public void close() throws IOException {
+        if (closed) {
+            return;
+        }
+
+        closed = true;
+        flush(); // sync
+    }
+
+    public void setOversized(int x, int z, boolean something) {
+    }
+
+    public CompoundTag getOversizedData(int x, int z) throws IOException {
+        throw new IOException("getOversizedData is a stub " + this.path);
+    }
+
+    @Override
+    public boolean recalculateHeader() {
+        return false;
+    }
+
+    public boolean isOversized(int x, int z) {
+        return false;
+    }
+
+    private class ChunkBuffer extends ByteArrayOutputStream {
+        private final ChunkPos pos;
+
+        public ChunkBuffer(ChunkPos chunkcoordintpair) {
+            super();
+            this.pos = chunkcoordintpair;
+        }
+
+        public void close() {
+            ByteBuffer bytebuffer = ByteBuffer.wrap(this.buf, 0, this.count);
+            LinearRegionFile.this.write(this.pos, bytebuffer);
+        }
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/region/LinearRegionFileFlusher.java b/src/main/java/dev/horizonmc/horizon/region/LinearRegionFileFlusher.java
new file mode 100644
index 0000000000000000000000000000000000000000..7858afc86a40a281ec64248019bf7601461246c5
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/region/LinearRegionFileFlusher.java
@@ -0,0 +1,55 @@
+package dev.horizonmc.horizon.region;
+
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import dev.horizonmc.horizon.HorizonConfig;
+import dev.horizonmc.horizon.HorizonLogger;
+
+import java.util.Queue;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.TimeUnit;
+
+// Powered by LinearPurpur(https://github.com/StupidCraft/LinearPurpur)
+public class LinearRegionFileFlusher {
+
+    private final Queue<LinearRegionFile> savingQueue = new LinkedBlockingQueue<>();
+    private final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor(
+            new ThreadFactoryBuilder()
+                    .setNameFormat("linear-flush-scheduler")
+                    .build()
+    );
+    private final ExecutorService executor = Executors.newFixedThreadPool(
+            HorizonConfig.getLinearFlushThreads(),
+            new ThreadFactoryBuilder()
+                    .setNameFormat("linear-flusher-%d")
+                    .build()
+    );
+
+    public LinearRegionFileFlusher() {
+        HorizonLogger.LOGGER.info("Using " + HorizonConfig.getLinearFlushThreads() + " threads for linear region flushing.");
+        scheduler.scheduleAtFixedRate(this::pollAndFlush, 0L, HorizonConfig.linearFlushFrequency, TimeUnit.SECONDS);
+    }
+
+    public void scheduleSave(LinearRegionFile regionFile) {
+        if (savingQueue.contains(regionFile)) {
+            return;
+        }
+        savingQueue.add(regionFile);
+    }
+
+    private void pollAndFlush() {
+        while (!savingQueue.isEmpty()) {
+            LinearRegionFile regionFile = savingQueue.poll();
+            if (!regionFile.closed && regionFile.isMarkedToSave()) {
+                executor.execute(regionFile::flushWrapper);
+            }
+        }
+    }
+
+    public void shutdown() {
+        executor.shutdown();
+        scheduler.shutdown();
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/region/RegionFileFormat.java b/src/main/java/dev/horizonmc/horizon/region/RegionFileFormat.java
new file mode 100644
index 0000000000000000000000000000000000000000..ef1e807a0021d47bf58fca549a90e187c293839a
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/region/RegionFileFormat.java
@@ -0,0 +1,5 @@
+package dev.horizonmc.horizon.region;
+
+public enum RegionFileFormat {
+    ANVIL, LINEAR
+}
diff --git a/src/main/java/net/minecraft/util/worldupdate/WorldUpgrader.java b/src/main/java/net/minecraft/util/worldupdate/WorldUpgrader.java
index cb39c629af1827078f35904a373d35a63fea17ff..45498ca01a580b344a354e8ca23eae9b902d2cb1 100644
--- a/src/main/java/net/minecraft/util/worldupdate/WorldUpgrader.java
+++ b/src/main/java/net/minecraft/util/worldupdate/WorldUpgrader.java
@@ -76,7 +76,7 @@ public class WorldUpgrader {
     volatile int skipped;
     final Reference2FloatMap<ResourceKey<Level>> progressMap = Reference2FloatMaps.synchronize(new Reference2FloatOpenHashMap());
     volatile Component status = Component.translatable("optimizeWorld.stage.counting");
-    static final Pattern REGEX = Pattern.compile("^r\\.(-?[0-9]+)\\.(-?[0-9]+)\\.mca$");
+    static final Pattern REGEX = Pattern.compile("^r\\.(-?[0-9]+)\\.(-?[0-9]+)\\.(linear | mca)$"); // Horizon
     final DimensionDataStorage overworldDataStorage;
 
     public WorldUpgrader(LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, RegistryAccess dynamicRegistryManager, boolean eraseCache, boolean recreateRegionFiles) {
@@ -400,7 +400,7 @@ public class WorldUpgrader {
 
         private static List<WorldUpgrader.FileToUpgrade> getAllChunkPositions(RegionStorageInfo key, Path regionDirectory) {
             File[] afile = regionDirectory.toFile().listFiles((file, s) -> {
-                return s.endsWith(".mca");
+                return s.endsWith(".mca") || s.endsWith(".linear"); // Horizon
             });
 
             if (afile == null) {
@@ -420,7 +420,7 @@ public class WorldUpgrader {
                         List<ChunkPos> list1 = Lists.newArrayList();
 
                         try {
-                            RegionFile regionfile = new RegionFile(key, file.toPath(), regionDirectory, true);
+                            dev.horizonmc.horizon.region.AbstractRegionFile regionfile = dev.horizonmc.horizon.region.AbstractRegionFileFactory.getAbstractRegionFile(key, file.toPath(), regionDirectory, true); // Horizon
 
                             try {
                                 for (int i1 = 0; i1 < 32; ++i1) {
@@ -483,7 +483,7 @@ public class WorldUpgrader {
 
         protected abstract boolean tryProcessOnePosition(T storage, ChunkPos chunkPos, ResourceKey<Level> worldKey);
 
-        private void onFileFinished(RegionFile regionFile) {
+        private void onFileFinished(dev.horizonmc.horizon.region.AbstractRegionFile regionFile) { // Horizon
             if (WorldUpgrader.this.recreateRegionFiles) {
                 if (this.previousWriteFuture != null) {
                     this.previousWriteFuture.join();
@@ -508,7 +508,7 @@ public class WorldUpgrader {
         }
     }
 
-    static record FileToUpgrade(RegionFile file, List<ChunkPos> chunksToUpgrade) {
+    static record FileToUpgrade(dev.horizonmc.horizon.region.AbstractRegionFile file, List<ChunkPos> chunksToUpgrade) { // Horizon
 
     }
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
index 1e0439cf3f4008fa430acb90b45f5bc4cdd6d7f2..aed8e8d25cf04c6c782e10ba0b80b4a4803714a2 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
@@ -28,7 +28,7 @@ import net.minecraft.nbt.NbtIo; // Paper
 import net.minecraft.world.level.ChunkPos;
 import org.slf4j.Logger;
 
-public class RegionFile implements AutoCloseable {
+public class RegionFile implements AutoCloseable, dev.horizonmc.horizon.region.AbstractRegionFile { // Horizon
 
     private static final Logger LOGGER = LogUtils.getLogger();
     private static final int SECTOR_BYTES = 4096;
@@ -129,7 +129,7 @@ public class RegionFile implements AutoCloseable {
     }
 
     // note: only call for CHUNK regionfiles
-    boolean recalculateHeader() throws IOException {
+    public boolean recalculateHeader() throws IOException { // Horizon - make it public
         if (!this.canRecalcHeader) {
             return false;
         }
@@ -928,10 +928,10 @@ public class RegionFile implements AutoCloseable {
     private static int getChunkIndex(int x, int z) {
         return (x & 31) + (z & 31) * 32;
     }
-    synchronized boolean isOversized(int x, int z) {
+    public synchronized boolean isOversized(int x, int z) { // Horizon
         return this.oversized[getChunkIndex(x, z)] == 1;
     }
-    synchronized void setOversized(int x, int z, boolean oversized) throws IOException {
+    public synchronized void setOversized(int x, int z, boolean oversized) throws IOException { // Horizon
         final int offset = getChunkIndex(x, z);
         boolean previous = this.oversized[offset] == 1;
         this.oversized[offset] = (byte) (oversized ? 1 : 0);
@@ -970,7 +970,7 @@ public class RegionFile implements AutoCloseable {
         return this.path.getParent().resolve(this.path.getFileName().toString().replaceAll("\\.mca$", "") + "_oversized_" + x + "_" + z + ".nbt");
     }
 
-    synchronized CompoundTag getOversizedData(int x, int z) throws IOException {
+    public synchronized CompoundTag getOversizedData(int x, int z) throws IOException { // Horizon
         Path file = getOversizedFile(x, z);
         try (DataInputStream out = new DataInputStream(new java.io.BufferedInputStream(new InflaterInputStream(Files.newInputStream(file))))) {
             return NbtIo.read((java.io.DataInput) out);
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
index 3ca0aa8f01ab5bc4524f2ee7b324c736e6c812c2..33b6e276b2381a67005db0572648c19dbac5228b 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
@@ -1,5 +1,6 @@
 package net.minecraft.world.level.chunk.storage;
 
+import dev.horizonmc.horizon.HorizonConfig;
 import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectIterator;
 import java.io.DataInput;
@@ -21,7 +22,7 @@ public class RegionFileStorage implements AutoCloseable, ca.spottedleaf.moonrise
 
     public static final String ANVIL_EXTENSION = ".mca";
     private static final int MAX_CACHE_SIZE = 256;
-    public final Long2ObjectLinkedOpenHashMap<RegionFile> regionCache = new Long2ObjectLinkedOpenHashMap();
+    public final Long2ObjectLinkedOpenHashMap<dev.horizonmc.horizon.region.AbstractRegionFile> regionCache = new Long2ObjectLinkedOpenHashMap(); // Horizon
     private final RegionStorageInfo info;
     private final Path folder;
     private final boolean sync;
@@ -31,9 +32,15 @@ public class RegionFileStorage implements AutoCloseable, ca.spottedleaf.moonrise
     private static final int MAX_NON_EXISTING_CACHE = 1024 * 64;
     private final it.unimi.dsi.fastutil.longs.LongLinkedOpenHashSet nonExistingRegionFiles = new it.unimi.dsi.fastutil.longs.LongLinkedOpenHashSet(MAX_NON_EXISTING_CACHE+1);
     private static String getRegionFileName(final int chunkX, final int chunkZ) {
-        return "r." + (chunkX >> REGION_SHIFT) + "." + (chunkZ >> REGION_SHIFT) + ".mca";
+        return "r." + (chunkX >> REGION_SHIFT) + "." + (chunkZ >> REGION_SHIFT) + (HorizonConfig.regionFormat != dev.horizonmc.horizon.region.RegionFileFormat.LINEAR ? ".mca" : ".linear"); // Horizon
     }
 
+    // Horizon start
+    private static String getOtherRegionFileName(final int chunkX, final int chunkZ) {
+        return "r." + (chunkX >> REGION_SHIFT) + "." + (chunkZ >> REGION_SHIFT) + (HorizonConfig.regionFormat == dev.horizonmc.horizon.region.RegionFileFormat.LINEAR ? ".mca" : ".linear");
+    }
+    // Horizon end
+
     private boolean doesRegionFilePossiblyExist(final long position) {
         synchronized (this.nonExistingRegionFiles) {
             if (this.nonExistingRegionFiles.contains(position)) {
@@ -66,15 +73,15 @@ public class RegionFileStorage implements AutoCloseable, ca.spottedleaf.moonrise
     }
 
     @Override
-    public synchronized final RegionFile moonrise$getRegionFileIfLoaded(final int chunkX, final int chunkZ) {
+    public synchronized final dev.horizonmc.horizon.region.AbstractRegionFile moonrise$getRegionFileIfLoaded(final int chunkX, final int chunkZ) { // Horizon
         return this.regionCache.getAndMoveToFirst(ChunkPos.asLong(chunkX >> REGION_SHIFT, chunkZ >> REGION_SHIFT));
     }
 
     @Override
-    public synchronized final RegionFile moonrise$getRegionFileIfExists(final int chunkX, final int chunkZ) throws IOException {
+    public synchronized final dev.horizonmc.horizon.region.AbstractRegionFile moonrise$getRegionFileIfExists(final int chunkX, final int chunkZ) throws IOException { // Horizon
         final long key = ChunkPos.asLong(chunkX >> REGION_SHIFT, chunkZ >> REGION_SHIFT);
 
-        RegionFile ret = this.regionCache.getAndMoveToFirst(key);
+        dev.horizonmc.horizon.region.AbstractRegionFile ret = this.regionCache.getAndMoveToFirst(key); // Horizon
         if (ret != null) {
             return ret;
         }
@@ -87,18 +94,23 @@ public class RegionFileStorage implements AutoCloseable, ca.spottedleaf.moonrise
             this.regionCache.removeLast().close();
         }
 
-        final Path regionPath = this.folder.resolve(getRegionFileName(chunkX, chunkZ));
+        // Horizon start
+        Path regionPath = this.folder.resolve(getRegionFileName(chunkX, chunkZ));
 
         if (!java.nio.file.Files.exists(regionPath)) {
-            this.markNonExisting(key);
-            return null;
+            regionPath = this.folder.resolve(getOtherRegionFileName(chunkX, chunkZ));
+            if (!java.nio.file.Files.exists(regionPath)) {
+                this.markNonExisting(key);
+                return null;
+            }
         }
+        // Horizon end
 
         this.createRegionFile(key);
 
         FileUtil.createDirectoriesSafe(this.folder);
 
-        ret = new RegionFile(this.info, regionPath, this.folder, this.sync);
+        ret = dev.horizonmc.horizon.region.AbstractRegionFileFactory.getAbstractRegionFile(this.info, regionPath, this.folder, this.sync); // Horizon
 
         this.regionCache.putAndMoveToFirst(key, ret);
 
@@ -143,7 +155,7 @@ public class RegionFileStorage implements AutoCloseable, ca.spottedleaf.moonrise
         this.isChunkData = isChunkDataFolder(this.folder); // Paper - recalculate region file headers
     }
 
-    public RegionFile getRegionFile(ChunkPos chunkcoordintpair, boolean existingOnly) throws IOException { // CraftBukkit // Paper - public
+    public dev.horizonmc.horizon.region.AbstractRegionFile getRegionFile(ChunkPos chunkcoordintpair, boolean existingOnly) throws IOException { // CraftBukkit // Paper - public // Horizon
         // Paper start - rewrite chunk system
         if (existingOnly) {
             return this.moonrise$getRegionFileIfExists(chunkcoordintpair.x, chunkcoordintpair.z);
@@ -151,7 +163,7 @@ public class RegionFileStorage implements AutoCloseable, ca.spottedleaf.moonrise
         synchronized (this) {
             final long key = ChunkPos.asLong(chunkcoordintpair.x >> REGION_SHIFT, chunkcoordintpair.z >> REGION_SHIFT);
 
-            RegionFile ret = this.regionCache.getAndMoveToFirst(key);
+            dev.horizonmc.horizon.region.AbstractRegionFile ret = this.regionCache.getAndMoveToFirst(key); // Horizon
             if (ret != null) {
                 return ret;
             }
@@ -166,7 +178,7 @@ public class RegionFileStorage implements AutoCloseable, ca.spottedleaf.moonrise
 
             FileUtil.createDirectoriesSafe(this.folder);
 
-            ret = new RegionFile(this.info, regionPath, this.folder, this.sync);
+            ret = dev.horizonmc.horizon.region.AbstractRegionFileFactory.getAbstractRegionFile(this.info, regionPath, this.folder, this.sync); // Horizon
 
             this.regionCache.putAndMoveToFirst(key, ret);
 
@@ -180,7 +192,7 @@ public class RegionFileStorage implements AutoCloseable, ca.spottedleaf.moonrise
         org.apache.logging.log4j.LogManager.getLogger().fatal(msg + " (" + file.toString().replaceAll(".+[\\\\/]", "") + " - " + x + "," + z + ") Go clean it up to remove this message. /minecraft:tp " + (x<<4)+" 128 "+(z<<4) + " - DO NOT REPORT THIS TO HORIZON - You may ask for help on Discord, but do not file an issue. These error messages can not be removed."); // Purpur // Horizon
     }
 
-    private static CompoundTag readOversizedChunk(RegionFile regionfile, ChunkPos chunkCoordinate) throws IOException {
+    private static CompoundTag readOversizedChunk(dev.horizonmc.horizon.region.AbstractRegionFile regionfile, ChunkPos chunkCoordinate) throws IOException { // Horizon
         synchronized (regionfile) {
             try (DataInputStream datainputstream = regionfile.getChunkDataInputStream(chunkCoordinate)) {
                 CompoundTag oversizedData = regionfile.getOversizedData(chunkCoordinate.x, chunkCoordinate.z);
@@ -215,7 +227,7 @@ public class RegionFileStorage implements AutoCloseable, ca.spottedleaf.moonrise
     @Nullable
     public CompoundTag read(ChunkPos pos) throws IOException {
         // CraftBukkit start - SPIGOT-5680: There's no good reason to preemptively create files on read, save that for writing
-        RegionFile regionfile = this.getRegionFile(pos, true);
+        dev.horizonmc.horizon.region.AbstractRegionFile regionfile = this.getRegionFile(pos, true); // Paper // Horizon
         if (regionfile == null) {
             return null;
         }
@@ -279,7 +291,7 @@ public class RegionFileStorage implements AutoCloseable, ca.spottedleaf.moonrise
 
     public void scanChunk(ChunkPos chunkPos, StreamTagVisitor scanner) throws IOException {
         // CraftBukkit start - SPIGOT-5680: There's no good reason to preemptively create files on read, save that for writing
-        RegionFile regionfile = this.getRegionFile(chunkPos, true);
+        dev.horizonmc.horizon.region.AbstractRegionFile regionfile = this.getRegionFile(chunkPos, true); // Horizon
         if (regionfile == null) {
             return;
         }
@@ -309,7 +321,7 @@ public class RegionFileStorage implements AutoCloseable, ca.spottedleaf.moonrise
     }
 
     public void write(ChunkPos pos, @Nullable CompoundTag nbt) throws IOException { // Paper - public
-        RegionFile regionfile = this.getRegionFile(pos, nbt == null); // CraftBukkit // Paper - rewrite chunk system
+        dev.horizonmc.horizon.region.AbstractRegionFile regionfile = this.getRegionFile(pos, nbt == null); // CraftBukkit // Paper - rewrite chunk system // Horizon
         // Paper start - rewrite chunk system
         if (regionfile == null) {
             // if the RegionFile doesn't exist, no point in deleting from it
@@ -325,7 +337,33 @@ public class RegionFileStorage implements AutoCloseable, ca.spottedleaf.moonrise
         if (nbt == null) {
             regionfile.clear(pos);
         } else {
-            DataOutputStream dataoutputstream = regionfile.getChunkDataOutputStream(pos);
+            // Horizon start - auto convert anvil to linear
+            DataOutputStream dataoutputstream;
+
+            if (regionfile instanceof RegionFile && HorizonConfig.regionFormat == dev.horizonmc.horizon.region.RegionFileFormat.LINEAR && HorizonConfig.autoConvertAnvilToLinear) {
+                Path linearFilePath = Path.of(regionfile.getPath().toString().replaceAll(".mca", ".linear"));
+                try (dev.horizonmc.horizon.region.LinearRegionFile linearRegionFile = new dev.horizonmc.horizon.region.LinearRegionFile(linearFilePath, HorizonConfig.linearCompressionLevel)) {
+                    DataInputStream regionDataInputStream = regionfile.getChunkDataInputStream(pos);
+                    if (regionDataInputStream == null) {
+                        continue;
+                    }
+
+                    CompoundTag compoundTag = NbtIo.read(regionDataInputStream);
+                    try (DataOutputStream linearDataOutputStream = linearRegionFile.getChunkDataOutputStream(pos)) {
+                        NbtIo.write(compoundTag, linearDataOutputStream);
+                    }
+
+                    linearRegionFile.flush();
+                    if(java.nio.file.Files.isRegularFile(regionfile.getPath())) {
+                        java.nio.file.Files.delete(regionfile.getPath());
+                    }
+
+                    dataoutputstream = linearRegionFile.getChunkDataOutputStream(pos);
+                }
+            } else {
+                dataoutputstream = regionfile.getChunkDataOutputStream(pos);
+            }
+            // Horizon end - auto convert anvil to linear
 
             try {
                 NbtIo.write(nbt, (DataOutput) dataoutputstream);
@@ -368,7 +406,7 @@ public class RegionFileStorage implements AutoCloseable, ca.spottedleaf.moonrise
         // Paper start - rewrite chunk system
         synchronized (this) {
             final ExceptionCollector<IOException> exceptionCollector = new ExceptionCollector<>();
-            for (final RegionFile regionFile : this.regionCache.values()) {
+            for (final dev.horizonmc.horizon.region.AbstractRegionFile regionFile : this.regionCache.values()) { // Horizon
                 try {
                     regionFile.close();
                 } catch (final IOException ex) {
@@ -385,7 +423,7 @@ public class RegionFileStorage implements AutoCloseable, ca.spottedleaf.moonrise
         // Paper start - rewrite chunk system
         synchronized (this) {
             final ExceptionCollector<IOException> exceptionCollector = new ExceptionCollector<>();
-            for (final RegionFile regionFile : this.regionCache.values()) {
+            for (final dev.horizonmc.horizon.region.AbstractRegionFile regionFile : this.regionCache.values()) { // Horizon
                 try {
                     regionFile.flush();
                 } catch (final IOException ex) {
