From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: GideonWhite1029 <gideonwhite1029@gmail.com>
Date: Sat, 13 Apr 2024 21:10:08 +0400
Subject: [PATCH] Fakeplayer support


diff --git a/src/main/java/dev/horizonmc/horizon/HorizonConfig.java b/src/main/java/dev/horizonmc/horizon/HorizonConfig.java
index 0f8b5ac1328be7455467d59c802fed1a3ae99802..8579c0bfc8ce36054e2a65ff540e79fb75bf11e3 100644
--- a/src/main/java/dev/horizonmc/horizon/HorizonConfig.java
+++ b/src/main/java/dev/horizonmc/horizon/HorizonConfig.java
@@ -13,6 +13,7 @@ import org.bukkit.configuration.file.YamlConfiguration;
 import java.io.File;
 import java.io.IOException;
 import java.util.Collections;
+import java.util.List;
 import java.util.logging.Level;
 
 public final class HorizonConfig {
@@ -177,4 +178,66 @@ public final class HorizonConfig {
         }
     }
     // Horizon end - Syncmatic Protocol
+
+    // Horizon start - Fakeplayer
+    @GlobalConfig(name = "use-action", category = {"fakeplayer"})
+    public static boolean fakeplayerUseAction = true;
+
+    @GlobalConfig(name = "modify-config", category = {"fakeplayer"})
+    public static boolean fakeplayerModifyConfig = false;
+
+    @GlobalConfig(name = "enable", category = {"fakeplayer"}, verify = FakeplayerVerify.class)
+    public static boolean fakeplayerSupport = true;
+
+    private static class FakeplayerVerify extends ConfigVerify.BooleanConfigVerify {
+        @Override
+        public String check(Boolean old, Boolean value) {
+            if (value) {
+                registerCommand("bot", new dev.horizonmc.horizon.bot.BotCommand("bot"));
+                dev.horizonmc.horizon.bot.agent.Actions.registerAll();
+            } else {
+                unregisterCommand("bot");
+            }
+            return null;
+        }
+    }
+
+    @GlobalConfig(name = "unable-fakeplayer-names", category = {"fakeplayer"}, verify = ConfigVerify.ListConfigVerify.class)
+    public static List<String> unableFakeplayerNames = List.of("player-name");
+
+    @GlobalConfig(name = "limit", category = {"fakeplayer"}, verify = ConfigVerify.IntConfigVerify.class)
+    public static int fakeplayerLimit = 10;
+
+    @GlobalConfig(name = "prefix", category = {"fakeplayer"}, verify = ConfigVerify.StringConfigVerify.class)
+    public static String fakeplayerPrefix = "";
+
+    @GlobalConfig(name = "suffix", category = {"fakeplayer"}, verify = ConfigVerify.StringConfigVerify.class)
+    public static String fakeplayerSuffix = "";
+
+    @GlobalConfig(name = "always-send-data", category = {"fakeplayer"})
+    public static boolean alwaysSendFakeplayerData = true;
+
+    @GlobalConfig(name = "resident-fakeplayer", category = {"fakeplayer"})
+    public static boolean fakeplayerResident = false;
+
+    @GlobalConfig(name = "open-fakeplayer-inventory", category = {"fakeplayer"})
+    public static boolean openFakeplayerInventory = false;
+
+    @GlobalConfig(name = "skip-sleep-check", category = {"fakeplayer"})
+    public static boolean fakeplayerSkipSleep = false;
+
+    @GlobalConfig(name = "spawn-phantom", category = {"fakeplayer"})
+    public static boolean fakeplayerSpawnPhantom = false;
+
+    @GlobalConfig(name = "regen-amount", category = {"fakeplayer"}, verify = RegenAmountVerify.class)
+    public static double fakeplayerRegenAmount = 0.010;
+
+    private static class RegenAmountVerify extends ConfigVerify.DoubleConfigVerify {
+        @Override
+        public String check(Double old, Double value) {
+            return value > 0.0 ? null : "regen-amount need > 0.0f";
+        }
+    }
+    // Horizon end - Fakeplayer
+
 }
diff --git a/src/main/java/dev/horizonmc/horizon/bot/BotCommand.java b/src/main/java/dev/horizonmc/horizon/bot/BotCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..f6fc0171d1dab8023ab05ec106e87904b555fc40
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/BotCommand.java
@@ -0,0 +1,406 @@
+package dev.horizonmc.horizon.bot;
+
+import dev.horizonmc.horizon.HorizonConfig;
+import dev.horizonmc.horizon.bot.agent.Actions;
+import dev.horizonmc.horizon.bot.agent.BotAction;
+import dev.horizonmc.horizon.bot.agent.CraftCustomBotAction;
+import dev.horizonmc.horizon.entity.Bot;
+import dev.horizonmc.horizon.event.bot.BotActionEvent;
+import dev.horizonmc.horizon.event.bot.BotConfigModifyEvent;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+import org.bukkit.generator.WorldInfo;
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionDefault;
+import org.bukkit.plugin.PluginManager;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.stream.Stream;
+
+public class BotCommand extends Command {
+
+    public BotCommand(String name) {
+        super(name);
+        this.description = "FakePlayer Command";
+        this.usageMessage = "/bot [create | remove | action | list | config]";
+        this.setPermission("bukkit.command.bot");
+        final PluginManager pluginManager = Bukkit.getServer().getPluginManager();
+        if (pluginManager.getPermission("bukkit.command.bot") == null) {
+            pluginManager.addPermission(new Permission("bukkit.command.bot", PermissionDefault.OP));
+        }
+    }
+
+    @Override
+    public @NotNull List<String> tabComplete(@NotNull CommandSender sender, @NotNull String alias, String @NotNull [] args, Location location) throws IllegalArgumentException {
+        var list = new ArrayList<String>();
+
+        if (args.length <= 1) {
+            list.add("create");
+            list.add("remove");
+            if (HorizonConfig.fakeplayerUseAction) {
+                list.add("action");
+            }
+            if (HorizonConfig.fakeplayerModifyConfig) {
+                list.add("config");
+            }
+            list.add("list");
+        }
+
+        if (args.length == 2) {
+            switch (args[0]) {
+                case "create" -> list.add("<BotName>");
+                case "remove", "action", "config" ->
+                        list.addAll(ServerBot.getBots().stream().map(e -> e.getName().getString()).toList());
+                case "list" -> list.addAll(Bukkit.getWorlds().stream().map(WorldInfo::getName).toList());
+            }
+        }
+
+        if (args.length == 3) {
+            switch (args[0]) {
+                case "action" -> {
+                    list.add("list");
+                    list.addAll(Actions.getNames());
+                }
+                case "create" -> list.add("<BotSkinName>");
+                case "config" -> list.addAll(acceptConfig);
+            }
+        }
+
+        if (args.length == 4) {
+            switch (args[0]) {
+                case "config" -> {
+                    if (args[2].equals(BotConfig.SIMULATION_DISTANCE.configName)) {
+                        list.add("10");
+                        list.add("2");
+                        list.add("<INT 2 - 32>");
+                    } else {
+                        list.add("true");
+                        list.add("false");
+                    }
+                }
+            }
+        }
+
+        if (args.length >= 4 && args[0].equals("action")) {
+            BotAction action = Actions.getForName(args[2]);
+            if (action != null) {
+                list.addAll(action.getArgument().tabComplete(args.length - 4));
+            }
+        }
+
+        return list;
+    }
+
+    @Override
+    public boolean execute(@NotNull CommandSender sender, @NotNull String commandLabel, String[] args) {
+        if (!testPermission(sender) || !HorizonConfig.fakeplayerSupport) return true;
+
+        if (args.length == 0) {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        switch (args[0]) {
+            case "create" -> this.onCreate(sender, args);
+
+            case "remove" -> this.onRemove(sender, args);
+
+            case "action" -> this.onAction(sender, args);
+
+            case "config" -> this.onConfig(sender, args);
+
+            case "list" -> this.onList(sender, args);
+
+            default -> {
+                sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    private void onCreate(CommandSender sender, String @NotNull [] args) {
+        if (args.length < 2) {
+            sender.sendMessage(ChatColor.RED + "Use /bot create <name> [skin_name] to create a fakeplayer");
+            return;
+        }
+
+        if (canCreate(sender, args[1])) {
+            if (sender instanceof Player player) {
+                new ServerBot.BotCreateState(player.getLocation(), args[1], args.length < 3 ? args[1] : args[2]).createAsync(bot -> bot.createPlayer = player.getUniqueId());
+            } else if (sender instanceof ConsoleCommandSender) {
+                if (args.length < 6) {
+                    sender.sendMessage(ChatColor.RED + "Use /bot create <name> <skin_name> <bukkit_world_name> <x> <y> <z> to create a fakeplayer");
+                    return;
+                }
+
+                try {
+                    World world = Bukkit.getWorld(args[3]);
+                    double x = Double.parseDouble(args[4]);
+                    double y = Double.parseDouble(args[5]);
+                    double z = Double.parseDouble(args[6]);
+
+                    if (world != null) {
+                        new ServerBot.BotCreateState(new Location(world, x, y, z), args[1], args[2]).createAsync(null);
+                    }
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+    }
+
+    private boolean canCreate(CommandSender sender, @NotNull String name) {
+        if (!name.matches("^[a-zA-Z0-9_]{4,16}$")) {
+            sender.sendMessage(ChatColor.RED + "This name is illegal");
+            return false;
+        }
+
+        if (Bukkit.getPlayerExact(name) != null || ServerBot.getBot(name) != null) {
+            sender.sendMessage(ChatColor.RED + "This player is in server");
+            return false;
+        }
+
+        if (dev.horizonmc.horizon.HorizonConfig.unableFakeplayerNames.contains(name)) {
+            sender.sendMessage(ChatColor.RED + "This name is not allowed");
+            return false;
+        }
+
+        if (ServerBot.getBots().size() >= dev.horizonmc.horizon.HorizonConfig.fakeplayerLimit) {
+            sender.sendMessage(ChatColor.RED + "Fakeplayer limit is full");
+            return false;
+        }
+
+        return true;
+    }
+
+    private void onRemove(CommandSender sender, String @NotNull [] args) {
+        if (args.length < 2) {
+            sender.sendMessage(ChatColor.RED + "Use /bot remove <name> to remove a fakeplayer");
+            return;
+        }
+
+        ServerBot bot = ServerBot.getBot(args[1]);
+
+        if (bot == null) {
+            sender.sendMessage(ChatColor.RED + "This fakeplayer is not in server");
+            return;
+        }
+
+        bot.die(bot.damageSources().fellOutOfWorld());
+    }
+
+    private void onAction(CommandSender sender, String @NotNull [] args) {
+        if (!HorizonConfig.fakeplayerUseAction) {
+            return;
+        }
+
+        if (args.length < 3) {
+            sender.sendMessage(ChatColor.RED + "Use /bot action <name> <action> to make fakeplayer do action");
+            return;
+        }
+
+        ServerBot bot = ServerBot.getBot(args[1]);
+        if (bot == null) {
+            sender.sendMessage(ChatColor.RED + "This fakeplayer is not in server");
+            return;
+        }
+
+        if (args[2].equals("list")) {
+            sender.sendMessage(bot.getScoreboardName() + "'s action list:");
+            for (BotAction action : bot.getBotActions()) {
+                sender.sendMessage(action.getName());
+            }
+            return;
+        }
+
+        BotAction action = Actions.getForName(args[2]);
+        if (action == null) {
+            sender.sendMessage(ChatColor.RED + "Invalid action");
+            return;
+        }
+
+        CraftPlayer player;
+        if (sender instanceof CraftPlayer) {
+            player = (CraftPlayer) sender;
+        } else {
+            player = bot.getBukkitEntity();
+        }
+
+        String[] realArgs = new String[args.length - 3];
+        if (realArgs.length != 0) {
+            System.arraycopy(args, 3, realArgs, 0, realArgs.length);
+        }
+
+        BotAction newAction;
+        if (action instanceof CraftCustomBotAction customBotAction) {
+            newAction = customBotAction.getNew(player, realArgs);
+        } else {
+            newAction = action.getNew(player.getHandle(), action.getArgument().parse(0, realArgs));
+        }
+
+        if (newAction == null) {
+            sender.sendMessage(ChatColor.RED + "Action create error, please check your arguments");
+            return;
+        }
+
+        BotActionEvent event = new BotActionEvent(bot.getBukkitEntity(), newAction.getName(), realArgs);
+        Bukkit.getPluginManager().callEvent(event);
+
+        if (!event.isCancelled()) {
+            bot.setBotAction(newAction);
+            sender.sendMessage("Action " + action.getName() + " has been issued to " + bot.getName().getString());
+        }
+    }
+
+    public enum BotConfig {
+        SKIP_SLEEP, SPAWN_PHANTOM, ALWAYS_SEND_DATA, SIMULATION_DISTANCE;
+
+        public final String configName;
+
+        BotConfig() {
+            this.configName = this.name().toLowerCase(Locale.ROOT);
+        }
+    }
+
+    private static final List<String> acceptConfig = Stream.of(BotConfig.values()).map(config -> config.configName).toList();
+
+    private void onConfig(CommandSender sender, String @NotNull [] args) {
+        if (!HorizonConfig.fakeplayerModifyConfig) {
+            return;
+        }
+
+        if (args.length < 3) {
+            sender.sendMessage(ChatColor.RED + "Use /bot config <name> <config> to modify fakeplayer's config");
+            return;
+        }
+
+        ServerBot bot = ServerBot.getBot(args[1]);
+        if (bot == null) {
+            sender.sendMessage(ChatColor.RED + "This fakeplayer is not in server");
+            return;
+        }
+
+        if (!acceptConfig.contains(args[2])) {
+            sender.sendMessage(ChatColor.RED + "This config is not accept");
+            return;
+        }
+
+        BotConfig config = BotConfig.valueOf(args[2].toUpperCase(Locale.ROOT));
+        if (args.length < 4) {
+            String value = null;
+            switch (config) {
+                case SKIP_SLEEP -> value = String.valueOf(bot.fauxSleeping);
+                case SPAWN_PHANTOM -> {
+                    sender.sendMessage(bot.getScoreboardName() + "'s spawn_phantom: " + bot.spawnPhantom);
+                    if (bot.spawnPhantom) {
+                        sender.sendMessage(bot.getScoreboardName() + "'s not_sleeping_ticks: " + bot.notSleepTicks);
+                    }
+                    return;
+                }
+                case ALWAYS_SEND_DATA -> value = String.valueOf(bot.alwaysSendData);
+                case SIMULATION_DISTANCE -> value = String.valueOf(bot.getBukkitEntity().getSimulationDistance());
+            }
+            sender.sendMessage(bot.getScoreboardName() + "'s " + config.configName + ": " + value);
+        } else {
+            String value = args[3];
+
+            BotConfigModifyEvent event = new BotConfigModifyEvent(bot.getBukkitEntity(), config.configName, value);
+            Bukkit.getPluginManager().callEvent(event);
+
+            if (event.isCancelled()) {
+                return;
+            }
+
+            switch (config) {
+                case SKIP_SLEEP -> {
+                    boolean realValue = value.equals("true");
+                    bot.fauxSleeping = realValue;
+                    value = String.valueOf(realValue);
+                }
+                case SPAWN_PHANTOM -> {
+                    boolean realValue = value.equals("true");
+                    bot.spawnPhantom = realValue;
+                    value = String.valueOf(realValue);
+                }
+                case ALWAYS_SEND_DATA -> {
+                    boolean realValue = value.equals("true");
+                    bot.alwaysSendData = realValue;
+                    value = String.valueOf(realValue);
+                }
+                case SIMULATION_DISTANCE -> {
+                    try {
+                        int realValue = Integer.parseInt(value);
+                        if (realValue < 2 || realValue > 32) {
+                            sender.sendMessage("simulation_distance must be a number between 2 and 32, got: " + value);
+                            return;
+                        }
+                        bot.getBukkitEntity().setSimulationDistance(realValue);
+                    } catch (NumberFormatException e) {
+                        sender.sendMessage("simulation_distance must be a number between 2 and 32, got: " + value);
+                        return;
+                    }
+                }
+            }
+            sender.sendMessage(bot.getScoreboardName() + "'s " + config.configName + " changed: " + value);
+        }
+    }
+
+    private void onList(CommandSender sender, String @NotNull [] args) {
+        if (args.length < 2) {
+            Map<World, List<String>> botMap = new HashMap<>();
+            for (World world : Bukkit.getWorlds()) {
+                botMap.put(world, new ArrayList<>());
+            }
+
+            for (ServerBot bot : ServerBot.getBots()) {
+                Bot bukkitBot = bot.getBukkitPlayer();
+                botMap.get(bukkitBot.getWorld()).add(bukkitBot.getName());
+            }
+
+            sender.sendMessage("Total number: (" + ServerBot.getBots().size() + "/" + dev.horizonmc.horizon.HorizonConfig.fakeplayerLimit + ")");
+            for (World world : botMap.keySet()) {
+                sender.sendMessage(world.getName() + "(" + botMap.get(world).size() + "): " + formatPlayerNameList(botMap.get(world)));
+            }
+        } else {
+            World world = Bukkit.getWorld(args[2]);
+
+            if (world == null) {
+                sender.sendMessage(ChatColor.RED + "Unknown world");
+                return;
+            }
+
+            List<String> botList = new ArrayList<>();
+            for (ServerBot bot : ServerBot.getBots()) {
+                Bot bukkitBot = bot.getBukkitPlayer();
+                if (bukkitBot.getWorld() == world) {
+                    botList.add(bukkitBot.getName());
+                }
+            }
+
+            sender.sendMessage(world.getName() + "(" + botList.size() + "): " + formatPlayerNameList(botList));
+        }
+    }
+
+    @NotNull
+    private static String formatPlayerNameList(@NotNull List<String> list) {
+        if (list.isEmpty()) {
+            return "";
+        }
+        String string = list.toString();
+        return string.substring(1, string.length() - 1);
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/bot/BotInventoryContainer.java b/src/main/java/dev/horizonmc/horizon/bot/BotInventoryContainer.java
new file mode 100644
index 0000000000000000000000000000000000000000..c1ba77adfa60075815d81e31a72245cbc097f01a
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/BotInventoryContainer.java
@@ -0,0 +1,180 @@
+package dev.horizonmc.horizon.bot;
+
+import com.google.common.collect.ImmutableList;
+import com.mojang.datafixers.util.Pair;
+import net.minecraft.core.NonNullList;
+import net.minecraft.network.chat.Component;
+import net.minecraft.world.ContainerHelper;
+import net.minecraft.world.SimpleContainer;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.Items;
+
+import javax.annotation.Nonnull;
+import java.util.List;
+
+// Power by gugle-carpet-addition(https://github.com/Gu-ZT/gugle-carpet-addition)
+public class BotInventoryContainer extends SimpleContainer {
+
+    public final NonNullList<ItemStack> items;
+    public final NonNullList<ItemStack> armor;
+    public final NonNullList<ItemStack> offhand;
+    private final List<NonNullList<ItemStack>> compartments;
+    private final NonNullList<ItemStack> buttons = NonNullList.withSize(13, ItemStack.EMPTY);
+    private final ServerBot player;
+
+    public BotInventoryContainer(ServerBot player) {
+        this.player = player;
+        this.items = this.player.getInventory().items;
+        this.armor = this.player.getInventory().armor;
+        this.offhand = this.player.getInventory().offhand;
+        this.compartments = ImmutableList.of(this.items, this.armor, this.offhand, this.buttons);
+        createButton();
+    }
+
+    @Override
+    public int getContainerSize() {
+        return this.items.size() + this.armor.size() + this.offhand.size() + this.buttons.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        for (ItemStack itemStack : this.items) {
+            if (itemStack.isEmpty()) {
+                continue;
+            }
+            return false;
+        }
+        for (ItemStack itemStack : this.armor) {
+            if (itemStack.isEmpty()) {
+                continue;
+            }
+            return false;
+        }
+        for (ItemStack itemStack : this.offhand) {
+            if (itemStack.isEmpty()) {
+                continue;
+            }
+            return false;
+        }
+        return true;
+    }
+
+    @Override
+    @Nonnull
+    public ItemStack getItem(int slot) {
+        Pair<NonNullList<ItemStack>, Integer> pair = getItemSlot(slot);
+        if (pair != null) {
+            return pair.getFirst().get(pair.getSecond());
+        } else {
+            return ItemStack.EMPTY;
+        }
+    }
+
+    public Pair<NonNullList<ItemStack>, Integer> getItemSlot(int slot) {
+        switch (slot) {
+            case 0 -> {
+                return new Pair<>(buttons, 0);
+            }
+            case 1, 2, 3, 4 -> {
+                return new Pair<>(armor, 4 - slot);
+            }
+            case 5, 6 -> {
+                return new Pair<>(buttons, slot - 4);
+            }
+            case 7 -> {
+                return new Pair<>(offhand, 0);
+            }
+            case 8, 9, 10, 11, 12, 13, 14, 15, 16, 17 -> {
+                return new Pair<>(buttons, slot - 5);
+            }
+            case 18, 19, 20, 21, 22, 23, 24, 25, 26,
+                 27, 28, 29, 30, 31, 32, 33, 34, 35,
+                 36, 37, 38, 39, 40, 41, 42, 43, 44 -> {
+                return new Pair<>(items, slot - 9);
+            }
+            case 45, 46, 47, 48, 49, 50, 51, 52, 53 -> {
+                return new Pair<>(items, slot - 45);
+            }
+            default -> {
+                return null;
+            }
+        }
+    }
+
+    @Override
+    @Nonnull
+    public ItemStack removeItem(int slot, int amount) {
+        Pair<NonNullList<ItemStack>, Integer> pair = getItemSlot(slot);
+        NonNullList<ItemStack> list = null;
+        ItemStack itemStack = ItemStack.EMPTY;
+        if (pair != null) {
+            list = pair.getFirst();
+            slot = pair.getSecond();
+        }
+        if (list != null && !list.get(slot).isEmpty()) {
+            itemStack = ContainerHelper.removeItem(list, slot, amount);
+            player.detectEquipmentUpdatesPublic();
+        }
+        return itemStack;
+    }
+
+    @Override
+    @Nonnull
+    public ItemStack removeItemNoUpdate(int slot) {
+        Pair<NonNullList<ItemStack>, Integer> pair = getItemSlot(slot);
+        NonNullList<ItemStack> list = null;
+        if (pair != null) {
+            list = pair.getFirst();
+            slot = pair.getSecond();
+        }
+        if (list != null && !list.get(slot).isEmpty()) {
+            ItemStack itemStack = list.get(slot);
+            list.set(slot, ItemStack.EMPTY);
+            return itemStack;
+        }
+        return ItemStack.EMPTY;
+    }
+
+    @Override
+    public void setItem(int slot, @Nonnull ItemStack stack) {
+        Pair<NonNullList<ItemStack>, Integer> pair = getItemSlot(slot);
+        NonNullList<ItemStack> list = null;
+        if (pair != null) {
+            list = pair.getFirst();
+            slot = pair.getSecond();
+        }
+        if (list != null) {
+            list.set(slot, stack);
+            player.detectEquipmentUpdatesPublic();
+        }
+    }
+
+    @Override
+    public void setChanged() {
+    }
+
+    @Override
+    public boolean stillValid(@Nonnull Player player) {
+        if (this.player.isRemoved()) {
+            return false;
+        }
+        return !(player.distanceToSqr(this.player) > 64.0);
+    }
+
+    @Override
+    public void clearContent() {
+        for (List<ItemStack> list : this.compartments) {
+            list.clear();
+        }
+    }
+
+    private void createButton() {
+        for (int i = 0; i < 13; i++) {
+            ItemStack button = new ItemStack(Items.STRUCTURE_VOID);
+            button.setHoverName(Component.empty());
+            button.getOrCreateTag().putBoolean("Horizon.Gui.Placeholder", true);
+            buttons.set(i, button);
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/horizonmc/horizon/bot/BotStatsCounter.java b/src/main/java/dev/horizonmc/horizon/bot/BotStatsCounter.java
new file mode 100644
index 0000000000000000000000000000000000000000..065c4deeeefa7bf50b4bcf150529ef8dc922f8df
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/BotStatsCounter.java
@@ -0,0 +1,35 @@
+package dev.horizonmc.horizon.bot;
+
+import com.mojang.datafixers.DataFixer;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.stats.ServerStatsCounter;
+import net.minecraft.stats.Stat;
+import net.minecraft.world.entity.player.Player;
+
+import java.io.File;
+
+public class BotStatsCounter extends ServerStatsCounter {
+
+    private static final File UNKOWN_FILE = new File("BOT_STATS_REMOVE_THIS");
+
+    public BotStatsCounter(MinecraftServer server) {
+        super(server, UNKOWN_FILE);
+    }
+
+    @Override
+    public void save() {
+    }
+
+    @Override
+    public void setValue(Player player, Stat<?> stat, int value) {
+    }
+
+    @Override
+    public void parseLocal(DataFixer dataFixer, String json) {
+    }
+
+    @Override
+    public int getValue(Stat<?> stat) {
+        return 0;
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/bot/BotUtil.java b/src/main/java/dev/horizonmc/horizon/bot/BotUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..0e07fa2ad31dff67310acde009929e387138c4b2
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/BotUtil.java
@@ -0,0 +1,183 @@
+package dev.horizonmc.horizon.bot;
+
+import com.google.common.base.Charsets;
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import dev.horizonmc.horizon.bot.agent.Actions;
+import dev.horizonmc.horizon.bot.agent.BotAction;
+import net.minecraft.core.NonNullList;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.nbt.ListTag;
+import net.minecraft.nbt.NbtAccounter;
+import net.minecraft.nbt.NbtIo;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.storage.LevelResource;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Collection;
+import java.util.Map;
+import java.util.UUID;
+
+public class BotUtil {
+
+    public static void replenishment(@NotNull ItemStack itemStack, NonNullList<ItemStack> itemStackList) {
+        int count = itemStack.getMaxStackSize() / 2;
+        if (itemStack.getCount() <= 8 && count > 8) {
+            for (ItemStack itemStack1 : itemStackList) {
+                if (itemStack1 == ItemStack.EMPTY || itemStack1 == itemStack) {
+                    continue;
+                }
+
+                if (ItemStack.isSameItemSameTags(itemStack1, itemStack)) {
+                    if (itemStack1.getCount() > count) {
+                        itemStack.setCount(itemStack.getCount() + count);
+                        itemStack1.setCount(itemStack1.getCount() - count);
+                    } else {
+                        itemStack.setCount(itemStack.getCount() + itemStack1.getCount());
+                        itemStack1.setCount(0);
+                    }
+                    break;
+                }
+            }
+        }
+    }
+
+    public static void replaceTool(@NotNull EquipmentSlot slot, ServerBot bot) {
+        ItemStack itemStack = bot.getItemBySlot(slot);
+        for (int i = 0; i < 36; i++) {
+            ItemStack itemStack1 = bot.getInventory().getItem(i);
+            if (itemStack1 == ItemStack.EMPTY || itemStack1 == itemStack) {
+                continue;
+            }
+
+            if (itemStack1.getItem().getClass() == itemStack.getItem().getClass() && !isDamage(itemStack1, 10)) {
+                ItemStack itemStack2 = itemStack1.copy();
+                bot.getInventory().setItem(i, itemStack);
+                bot.setItemSlot(slot, itemStack2);
+                return;
+            }
+        }
+
+        for (int i = 0; i < 36; i++) {
+            ItemStack itemStack1 = bot.getInventory().getItem(i);
+            if (itemStack1 == ItemStack.EMPTY && itemStack1 != itemStack) {
+                bot.getInventory().setItem(i, itemStack);
+                bot.setItemSlot(slot, ItemStack.EMPTY);
+                return;
+            }
+        }
+    }
+
+    public static boolean isDamage(@NotNull ItemStack item, int minDamage) {
+        return item.isDamageableItem() && (item.getMaxDamage() - item.getDamageValue()) <= minDamage;
+    }
+
+    @NotNull
+    public static JsonObject saveBot(@NotNull ServerBot bot) {
+        double pos_x = bot.getX();
+        double pos_y = bot.getY();
+        double pos_z = bot.getZ();
+        float yaw = bot.getYRot();
+        float pitch = bot.getXRot();
+        String dimension = bot.getLocation().getWorld().getName();
+        String skin = bot.createState.skinName;
+
+        JsonObject fakePlayer = new JsonObject();
+        fakePlayer.addProperty("pos_x", pos_x);
+        fakePlayer.addProperty("pos_y", pos_y);
+        fakePlayer.addProperty("pos_z", pos_z);
+        fakePlayer.addProperty("yaw", yaw);
+        fakePlayer.addProperty("pitch", pitch);
+        fakePlayer.addProperty("dimension", dimension);
+        fakePlayer.addProperty("skin", skin);
+
+        Collection<BotAction> actions = bot.getBotActions();
+        JsonArray botActions = new JsonArray();
+        for (BotAction action : actions) {
+            JsonObject actionObj = new JsonObject();
+            actionObj.addProperty("name", action.getName());
+            actionObj.addProperty("number", String.valueOf(action.getNumber()));
+            actionObj.addProperty("delay", String.valueOf(action.getTickDelay()));
+            botActions.add(actionObj);
+        }
+        fakePlayer.add("actions", botActions);
+
+        CompoundTag invnbt = new CompoundTag();
+        invnbt.put("Inventory", bot.getInventory().save(new ListTag()));
+
+        File file = MinecraftServer.getServer().getWorldPath(LevelResource.ROOT).resolve("fakeplayer/" + bot.getStringUUID() + ".dat").toFile();
+        File parent = file.getParentFile();
+        try {
+            if (!parent.exists() || !parent.isDirectory()) {
+                parent.mkdirs();
+            }
+            if (file.exists() && file.isFile()) {
+                file.delete();
+            }
+            file.createNewFile();
+            NbtIo.writeCompressed(invnbt, file.toPath());
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        return fakePlayer;
+    }
+
+    public static void loadBot(Map.@NotNull Entry<String, JsonElement> entry) {
+        String username = entry.getKey();
+        JsonObject fakePlayer = entry.getValue().getAsJsonObject();
+        double pos_x = fakePlayer.get("pos_x").getAsDouble();
+        double pos_y = fakePlayer.get("pos_y").getAsDouble();
+        double pos_z = fakePlayer.get("pos_z").getAsDouble();
+        float yaw = fakePlayer.get("yaw").getAsFloat();
+        float pitch = fakePlayer.get("pitch").getAsFloat();
+        String dimension = fakePlayer.get("dimension").getAsString();
+        String skin = fakePlayer.get("skin").getAsString();
+
+        Location location = new Location(Bukkit.getWorld(dimension), pos_x, pos_y, pos_z, yaw, pitch);
+        ServerBot.BotCreateState state = new ServerBot.BotCreateState(location, username, skin);
+
+        ListTag inv = null;
+        File file = MinecraftServer.getServer().getWorldPath(LevelResource.ROOT).resolve("fakeplayer/" + getBotUUID(state) + ".dat").toFile();
+        if (file.exists()) {
+            try {
+                CompoundTag nbt = NbtIo.readCompressed(file.toPath(), NbtAccounter.unlimitedHeap());
+                inv = nbt.getList("Inventory", 10);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+            file.delete();
+        }
+
+        final JsonArray finalActions = fakePlayer.get("actions").getAsJsonArray();
+        final ListTag finalInv = inv;
+        state.createAsync(serverBot -> {
+            if (finalInv != null) {
+                serverBot.getInventory().load(finalInv);
+            }
+
+            for (JsonElement element : finalActions) {
+                JsonObject actionObj = element.getAsJsonObject();
+                BotAction action = Actions.getForName(actionObj.get("name").getAsString());
+                if (action != null) {
+                    BotAction newAction = action.getNew(serverBot,
+                            action.getArgument().parse(0, new String[]{actionObj.get("delay").getAsString(), actionObj.get("number").getAsString()})
+                    );
+                    serverBot.setBotAction(newAction);
+                }
+            }
+        });
+    }
+
+    @NotNull
+    public static UUID getBotUUID(ServerBot.@NotNull BotCreateState state) {
+        return UUID.nameUUIDFromBytes(("Fakeplayer:" + state.getRealName()).getBytes(Charsets.UTF_8));
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/bot/MojangAPI.java b/src/main/java/dev/horizonmc/horizon/bot/MojangAPI.java
new file mode 100644
index 0000000000000000000000000000000000000000..a1934ae56fd90ce4cd4c8f095d02100e69ceec99
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/MojangAPI.java
@@ -0,0 +1,41 @@
+package dev.horizonmc.horizon.bot;
+
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParser;
+
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.net.URL;
+import java.util.HashMap;
+import java.util.Map;
+
+public class MojangAPI {
+
+    private static final boolean CACHE_ENABLED = false;
+
+    private static final Map<String, String[]> CACHE = new HashMap<>();
+
+    public static String[] getSkin(String name) {
+        if (CACHE_ENABLED && CACHE.containsKey(name)) {
+            return CACHE.get(name);
+        }
+
+        String[] values = pullFromAPI(name);
+        CACHE.put(name, values);
+        return values;
+    }
+
+    // Laggggggggggggggggggggggggggggggggggggggggg
+    public static String[] pullFromAPI(String name) {
+        try {
+            String uuid = new JsonParser().parse(new InputStreamReader(new URL("https://api.mojang.com/users/profiles/minecraft/" + name)
+                    .openStream())).getAsJsonObject().get("id").getAsString();
+            JsonObject property = new JsonParser()
+                    .parse(new InputStreamReader(new URL("https://sessionserver.mojang.com/session/minecraft/profile/"  +uuid + "?unsigned=false")
+                            .openStream())).getAsJsonObject().get("properties").getAsJsonArray().get(0).getAsJsonObject();
+            return new String[]{property.get("value").getAsString(), property.get("signature").getAsString()};
+        } catch (IOException | IllegalStateException e) {
+            return null;
+        }
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/bot/ServerBot.java b/src/main/java/dev/horizonmc/horizon/bot/ServerBot.java
new file mode 100644
index 0000000000000000000000000000000000000000..0b9a209af38eb5697c354f62158aca1b7efc5743
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/ServerBot.java
@@ -0,0 +1,886 @@
+package dev.horizonmc.horizon.bot;
+
+import com.google.common.collect.Lists;
+import com.google.gson.Gson;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.properties.Property;
+import net.minecraft.Util;
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.Connection;
+import net.minecraft.network.PacketSendListener;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.network.protocol.game.ClientboundAddEntityPacket;
+import net.minecraft.network.protocol.game.ClientboundPlayerInfoRemovePacket;
+import net.minecraft.network.protocol.game.ClientboundPlayerInfoUpdatePacket;
+import net.minecraft.network.protocol.game.ClientboundRemoveEntitiesPacket;
+import net.minecraft.network.protocol.game.ClientboundRotateHeadPacket;
+import net.minecraft.network.syncher.EntityDataAccessor;
+import net.minecraft.network.syncher.EntityDataSerializers;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ClientInformation;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.network.CommonListenerCookie;
+import net.minecraft.server.network.ServerGamePacketListenerImpl;
+import net.minecraft.server.network.ServerPlayerConnection;
+import net.minecraft.stats.ServerStatsCounter;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.InteractionResult;
+import net.minecraft.world.SimpleMenuProvider;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.EquipmentSlot;
+import net.minecraft.world.entity.ai.attributes.Attributes;
+import net.minecraft.world.entity.item.ItemEntity;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.inventory.ChestMenu;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.level.gameevent.GameEvent;
+import net.minecraft.world.level.storage.LevelResource;
+import net.minecraft.world.phys.AABB;
+import net.minecraft.world.phys.Vec3;
+import org.bukkit.Bukkit;
+import org.bukkit.ChatColor;
+import org.bukkit.Location;
+import org.bukkit.Material;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.scheduler.CraftScheduler;
+import org.bukkit.event.entity.CreatureSpawnEvent;
+import org.bukkit.event.entity.EntityKnockbackEvent;
+import org.bukkit.util.Vector;
+import org.jetbrains.annotations.NotNull;
+import dev.horizonmc.horizon.HorizonConfig;
+import dev.horizonmc.horizon.bot.agent.BotAction;
+import dev.horizonmc.horizon.bot.agent.StopAction;
+import dev.horizonmc.horizon.entity.Bot;
+import dev.horizonmc.horizon.entity.CraftBot;
+import dev.horizonmc.horizon.event.bot.BotCreateEvent;
+import dev.horizonmc.horizon.event.bot.BotInventoryOpenEvent;
+import dev.horizonmc.horizon.event.bot.BotJoinEvent;
+import dev.horizonmc.horizon.util.MathUtils;
+
+import javax.annotation.Nullable;
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.util.Collection;
+import java.util.EnumSet;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.function.Consumer;
+
+// TODO remake all
+
+
+public class ServerBot extends ServerPlayer {
+
+
+    private final Map<String, BotAction> actions;
+
+    private final boolean removeOnDeath;
+
+    private final int tracingRange;
+
+
+    private Vec3 velocity;
+
+    private int fireTicks;
+
+    private int jumpTicks;
+
+    private int noFallTicks;
+
+    public boolean waterSwim;
+
+    private Vec3 knockback;
+
+    public BotCreateState createState;
+
+    public UUID createPlayer;
+
+
+    private final ServerStatsCounter stats;
+
+    private final BotInventoryContainer container;
+
+
+    private static final List<ServerBot> bots = new CopyOnWriteArrayList<>();
+
+
+    public boolean spawnPhantom;
+
+    public int notSleepTicks;
+
+    public boolean alwaysSendData;
+
+
+    private ServerBot(MinecraftServer server, ServerLevel world, GameProfile profile) {
+        super(server, world, profile, ClientInformation.createDefault());
+        this.entityData.set(new EntityDataAccessor<>(16, EntityDataSerializers.INT), 0xFF);
+        this.entityData.set(Player.DATA_PLAYER_MODE_CUSTOMISATION, (byte) -2);
+
+        this.gameMode = new ServerBotGameMode(this);
+        this.velocity = new Vec3(this.xxa, this.yya, this.zza);
+        this.noFallTicks = 60;
+        this.fireTicks = 0;
+        this.actions = new HashMap<>();
+        this.removeOnDeath = true;
+        this.stats = new BotStatsCounter(server);
+        this.container = new BotInventoryContainer(this);
+        this.waterSwim = true;
+        this.knockback = Vec3.ZERO;
+        this.tracingRange = world.spigotConfig.playerTrackingRange * world.spigotConfig.playerTrackingRange;
+        this.notSleepTicks = 0;
+
+        this.fauxSleeping = HorizonConfig.fakeplayerSkipSleep;
+        this.spawnPhantom = HorizonConfig.fakeplayerSpawnPhantom;
+        this.alwaysSendData = HorizonConfig.alwaysSendFakeplayerData;
+
+    }
+
+
+    public static ServerBot createBot(@NotNull BotCreateState state) {
+        if (!isCreateLegal(state.name)) {
+            return null;
+
+        }
+
+        MinecraftServer server = MinecraftServer.getServer();
+
+        BotCreateEvent
+                event = new BotCreateEvent(state.name, state.skinName, state.loc, ChatColor.YELLOW + state.name + " joined the game");
+        server.server.getPluginManager().callEvent(event);
+
+        if (event.isCancelled()) {
+            return null;
+
+        }
+
+        Location location = event.getCreateLocation();
+
+        ServerLevel world = ((CraftWorld) location.getWorld()).getHandle();
+        CustomGameProfile profile = new CustomGameProfile(BotUtil.getBotUUID(state), state.name, state.skin);
+
+        ServerBot bot = new ServerBot(server, world, profile);
+
+        bot.connection = new ServerGamePacketListenerImpl(server, new Connection(PacketFlow.SERVERBOUND) { // ?
+            @Override
+
+
+            public void send(@NotNull Packet<?> packet) {
+
+            }
+
+            @Override
+
+
+            public void send(@NotNull Packet<?> packet, @Nullable PacketSendListener packetsendlistener) {
+
+            }
+
+            @Override
+
+
+            public void send(@NotNull Packet<?> packet, @Nullable PacketSendListener callbacks, boolean flush) {
+
+            }
+
+        }, bot, CommonListenerCookie.createInitial(profile));
+        bot.isRealPlayer = true;
+        bot.createState = state;
+
+        if (event.getJoinMessage() != null) {
+            Bukkit.broadcastMessage(event.getJoinMessage());
+
+        }
+
+        bot.teleportTo(location.getX(), location.getY(), location.getZ());
+        bot.setRot(location.getYaw(), location.getPitch());
+        bot.getBukkitEntity().setRotation(location.getYaw(), location.getPitch());
+        world.addFreshEntity(bot, CreatureSpawnEvent.SpawnReason.COMMAND);
+
+        bot.renderAll();
+        server.getPlayerList().addNewBot(bot);
+        bots.add(bot);
+
+        BotJoinEvent event1 = new BotJoinEvent(bot.getBukkitPlayer());
+        server.server.getPluginManager().callEvent(event1);
+
+        return bot;
+
+    }
+
+
+    public static boolean isCreateLegal(@NotNull String name) {
+        if (!name.matches("^[a-zA-Z0-9_]{4,16}$")) {
+            return false;
+
+        }
+
+        if (Bukkit.getPlayer(name) != null || ServerBot.getBot(name) != null) {
+            return false;
+
+        }
+
+        if (dev.horizonmc.horizon.HorizonConfig.unableFakeplayerNames.contains(name)) {
+            return false;
+
+        }
+
+        return ServerBot.getBots().size() < dev.horizonmc.horizon.HorizonConfig.fakeplayerLimit;
+
+    }
+
+
+    public void renderAll() {
+        MinecraftServer.getServer().getPlayerList().getPlayers().forEach(
+                player -> {
+                    this.sendPlayerInfo(player);
+                    this.sendFakeData(player.connection, false);
+
+                }
+        );
+
+    }
+
+
+    public void sendPlayerInfo(ServerPlayer player) {
+        player.connection.send(new ClientboundPlayerInfoUpdatePacket(EnumSet.of(ClientboundPlayerInfoUpdatePacket.Action.ADD_PLAYER, ClientboundPlayerInfoUpdatePacket.Action.UPDATE_LISTED, ClientboundPlayerInfoUpdatePacket.Action.UPDATE_DISPLAY_NAME), List.of(this)));
+
+    }
+
+
+    public boolean needSendFakeData(ServerPlayer player) {
+
+        return alwaysSendData && (player.level() == this.level() && player.position().distanceToSqr(this.position()) > this.tracingRange);
+
+    }
+
+
+    public void sendFakeDataIfNeed(ServerPlayer player, boolean login) {
+        if (needSendFakeData(player)) {
+            this.sendFakeData(player.connection, login);
+
+        }
+
+    }
+
+
+    public void sendFakeData(ServerPlayerConnection playerConnection, boolean login) {
+        playerConnection.send(new ClientboundAddEntityPacket(this));
+        if (login) {
+            Bukkit.getScheduler().runTaskLater(CraftScheduler.MINECRAFT, () -> {
+                connection.send(new ClientboundRotateHeadPacket(this, (byte) ((getYRot() * 256f) / 360f)));
+
+            }, 10);
+
+        } else {
+            connection.send(new ClientboundRotateHeadPacket(this, (byte) ((getYRot() * 256f) / 360f)));
+
+        }
+
+    }
+
+
+    private void sendPacket(Packet<?> packet) {
+        MinecraftServer.getServer().getPlayerList().getPlayers().forEach(
+                player -> player.connection.send(packet)
+        );
+
+    }
+
+    // die check start
+
+    @Override
+
+
+    public void die(@NotNull DamageSource damageSource) {
+        super.die(damageSource);
+        this.dieCheck();
+
+    }
+
+
+    private void dieCheck() {
+        if (removeOnDeath) {
+            bots.remove(this);
+            server.getPlayerList().removeBot(this);
+            remove(RemovalReason.KILLED);
+            this.setDead();
+            this.removeTab();
+            Bukkit.broadcastMessage(ChatColor.YELLOW + this.getName().getString() + " left the game"); // TODO i18n
+
+        }
+
+    }
+
+
+    private void removeTab() {
+        sendPacket(new ClientboundPlayerInfoRemovePacket(List.of(this.getUUID())));
+
+    }
+
+
+    private void setDead() {
+        sendPacket(new ClientboundRemoveEntitiesPacket(getId()));
+        this.dead = true;
+        this.inventoryMenu.removed(this);
+        this.containerMenu.removed(this);
+
+    }
+
+    // die check end
+
+
+    @Nullable
+
+    @Override
+
+
+    public Entity changeDimension(@NotNull ServerLevel destination) {
+        return null; // disable dimension change
+
+    }
+
+
+    public Bot getBukkitPlayer() {
+        return getBukkitEntity();
+
+    }
+
+
+    @Override
+
+    @NotNull
+
+
+    public CraftBot getBukkitEntity() {
+        return (CraftBot) super.getBukkitEntity();
+
+    }
+
+
+    @Override
+
+
+    public boolean isInWater() {
+        Location loc = getLocation();
+        for (int i = 0; i <= 2; i++) {
+            Material type = loc.getBlock().getType();
+            if (type == Material.WATER || type == Material.LAVA) {
+                return true;
+
+            }
+            loc.add(0, 0.9, 0);
+
+        }
+        return false;
+
+    }
+
+
+    @Override
+
+
+    public void tick() {
+        super.tick();
+        this.doTick();
+
+        if (!isAlive()) {
+            return;
+
+        }
+
+        if (spawnPhantom) {
+            ++notSleepTicks;
+        }
+
+        if (fireTicks > 0) {
+            --fireTicks;
+
+        }
+        if (jumpTicks > 0) {
+            --jumpTicks;
+
+        }
+        if (noFallTicks > 0) {
+            --noFallTicks;
+
+        }
+        if (takeXpDelay > 0) {
+            --takeXpDelay;
+
+        }
+
+        this.updateLocation();
+        this.updatePlayerPose();
+
+        if (server.getTickCount() % 20 == 0) {
+            float health = getHealth();
+            float maxHealth = getMaxHealth();
+            float regenAmount = (float) (HorizonConfig.fakeplayerRegenAmount * 20);
+            float amount;
+
+            if (health < maxHealth - regenAmount) {
+                amount = health + regenAmount;
+
+            } else {
+                amount = maxHealth;
+
+            }
+
+            this.setHealth(amount);
+
+        }
+
+        BlockPos blockposition = this.getOnPosLegacy();
+        BlockState iblockdata = this.level().getBlockState(blockposition);
+        Vec3 vec3d1 = this.collide(velocity);
+        this.checkFallDamage(vec3d1.y, this.onGround(), iblockdata, blockposition);
+
+        ++this.attackStrengthTicker;
+
+        if (this.getHealth() > 0.0F) {
+            AABB axisalignedbb;
+
+            if (this.isPassenger() && !this.getVehicle().isRemoved()) {
+                axisalignedbb = this.getBoundingBox().minmax(this.getVehicle().getBoundingBox()).inflate(1.0D, 0.0D, 1.0D);
+
+            } else {
+                axisalignedbb = this.getBoundingBox().inflate(1.0D, 0.5D, 1.0D);
+
+            }
+
+            List<Entity> list = this.level().getEntities(this, axisalignedbb);
+            List<Entity> list1 = Lists.newArrayList();
+
+            for (Entity entity : list) {
+                if (entity.getType() == EntityType.EXPERIENCE_ORB) {
+                    list1.add(entity);
+
+                } else if (!entity.isRemoved()) {
+                    this.touch(entity);
+
+                }
+
+            }
+
+            if (!list1.isEmpty()) {
+                this.touch(Util.getRandom(list1, this.random));
+
+            }
+
+        }
+
+        Iterator<Map.Entry<String, BotAction>> iterator = actions.entrySet().iterator();
+        while (iterator.hasNext()) {
+            Map.Entry<String, BotAction> entry = iterator.next();
+            if (entry.getValue().isCancel()) {
+                iterator.remove();
+
+            } else {
+                entry.getValue().tryTick(this);
+
+            }
+
+        }
+
+    }
+
+
+    private void touch(@NotNull Entity entity) {
+        entity.playerTouch(this);
+
+    }
+
+
+    @Override
+
+
+    public void onItemPickup(@NotNull ItemEntity item) {
+        super.onItemPickup(item);
+        this.updateItemInHand(InteractionHand.MAIN_HAND);
+
+    }
+
+
+    public void updateItemInHand(InteractionHand hand) {
+        net.minecraft.world.item.ItemStack item = getItemInHand(hand);
+
+        if (!item.isEmpty()) {
+            BotUtil.replenishment(item, getInventory().items);
+            if (BotUtil.isDamage(item, 10)) {
+                BotUtil.replaceTool(hand == InteractionHand.MAIN_HAND ? EquipmentSlot.MAINHAND : EquipmentSlot.OFFHAND, this);
+
+            }
+
+        }
+        detectEquipmentUpdatesPublic();
+
+    }
+
+
+    @Override
+
+
+    public void checkFallDamage(double heightDifference, boolean onGround, @NotNull BlockState state, @NotNull BlockPos landedPosition) {
+        if (onGround) {
+            if (this.fallDistance > 0.0F) {
+                state.getBlock().fallOn(this.level(), state, landedPosition, this, this.fallDistance);
+                this.level().gameEvent(GameEvent.HIT_GROUND, this.position(), GameEvent.Context.of(this, this.mainSupportingBlockPos.map((blockposition1) -> {
+                    return this.level().getBlockState(blockposition1);
+
+                }).orElse(state)));
+
+            }
+
+            this.resetFallDistance();
+
+        } else if (heightDifference < 0.0D) {
+            this.fallDistance -= (float) heightDifference;
+
+        }
+
+    }
+
+
+    @Override
+
+
+    public void doTick() {
+        if (this.hurtTime > 0) {
+            this.hurtTime -= 1;
+
+        }
+
+        baseTick();
+
+        this.lerpSteps = (int) this.zza;
+        this.animStep = this.run;
+        this.yRotO = this.getYRot();
+        this.xRotO = this.getXRot();
+
+    }
+
+
+    public Location getLocation() {
+        return getBukkitPlayer().getLocation();
+
+    }
+
+
+    @Override
+    public void knockback(double strength, double x, double z, @Nullable Entity knockingBackEntity, EntityKnockbackEvent.@NotNull KnockbackCause cause) {
+        strength *= 1.0D - this.getAttributeValue(Attributes.KNOCKBACK_RESISTANCE);
+        if (strength > 0.0D) {
+            this.hasImpulse = true;
+            Vec3 vec3d = this.getDeltaMovement();
+            Vec3 vec3d1 = (new Vec3(x, 0.0D, z)).normalize().scale(strength);
+            knockback = new Vec3(vec3d.x / 2.0D - vec3d1.x, this.onGround() ? Math.min(0.4D, vec3d.y / 2.0D + strength) : vec3d.y, vec3d.z / 2.0D - vec3d1.z);
+
+        }
+    }
+
+
+    private void updateLocation() {
+        this.velocity = new Vec3(this.xxa, this.yya, this.zza);
+        if (waterSwim && isInWater()) {
+            this.addDeltaMovement(new Vec3(0, 0.05, 0));
+
+        }
+        this.addDeltaMovement(knockback);
+        knockback = Vec3.ZERO;
+        this.travel(this.velocity);
+    }
+
+
+    public void faceLocation(@NotNull Location loc) {
+        look(loc.toVector().subtract(getLocation().toVector()), false);
+    }
+
+
+    public void look(Vector dir, boolean keepYaw) {
+        float yaw, pitch;
+        if (keepYaw) {
+            yaw = this.getYHeadRot();
+            pitch = MathUtils.fetchPitch(dir);
+        } else {
+            float[] vals = MathUtils.fetchYawPitch(dir);
+            yaw = vals[0];
+            pitch = vals[1];
+
+            sendPacket(new ClientboundRotateHeadPacket(this, (byte) (yaw * 256 / 360f)));
+        }
+        setRot(yaw, pitch);
+        this.getBukkitEntity().setRotation(yaw, pitch);
+    }
+
+
+    public void attack(@NotNull Entity target) {
+        super.attack(target);
+        swing(InteractionHand.MAIN_HAND);
+    }
+
+
+    @Override
+    public void jumpFromGround() {
+        double jumpPower = (double) this.getJumpPower() + this.getJumpBoostPower();
+        this.addDeltaMovement(new Vec3(0, jumpPower, 0));
+
+    }
+
+
+    public void dropAll() {
+        getInventory().dropAll();
+        detectEquipmentUpdatesPublic();
+    }
+
+
+    public void setBotAction(BotAction action) {
+        if (!HorizonConfig.fakeplayerUseAction) {
+            return;
+        }
+        if (action instanceof StopAction) {
+            this.actions.clear();
+        }
+        action.init();
+        this.actions.put(action.getName(), action);
+    }
+
+
+    public Collection<BotAction> getBotActions() {
+        return actions.values();
+    }
+
+
+    public BotAction getBotAction(String name) {
+        return actions.get(name);
+    }
+
+
+    @Deprecated
+    public BotAction getBotAction() {
+        return null;
+
+    }
+
+
+    @Override
+    public @NotNull ServerStatsCounter getStats() {
+        return stats;
+
+    }
+
+
+    public BotInventoryContainer getContainer() {
+        return container;
+    }
+
+
+    @Override
+    public @NotNull InteractionResult interact(@NotNull Player player, @NotNull InteractionHand hand) {
+        if (HorizonConfig.openFakeplayerInventory) {
+            if (player instanceof ServerPlayer player1 && player.getMainHandItem().isEmpty()) {
+                BotInventoryOpenEvent
+                        event = new BotInventoryOpenEvent(this.getBukkitEntity(), player1.getBukkitEntity());
+                server.server.getPluginManager().callEvent(event);
+                if (!event.isCancelled()) {
+                    player.openMenu(new SimpleMenuProvider((i, inventory, p) -> ChestMenu.sixRows(i, inventory, container), getDisplayName()));
+                    return InteractionResult.SUCCESS;
+                }
+            }
+        }
+        return super.interact(player, hand);
+    }
+
+
+    public static ServerBot getBot(ServerPlayer player) {
+        ServerBot bot = null;
+        for (ServerBot b : bots) {
+            if (b.getId() == player.getId()) {
+                bot = b;
+                break;
+            }
+        }
+        return bot;
+    }
+
+
+    public static ServerBot getBot(String name) {
+        ServerBot bot = null;
+        for (ServerBot b : bots) {
+            if (b.getName().getString().equals(name)) {
+                bot = b;
+                break;
+            }
+        }
+        return bot;
+    }
+
+
+    public static ServerBot getBot(UUID uuid) {
+        ServerBot bot = null;
+        for (ServerBot b : bots) {
+            if (b.uuid == uuid) {
+                bot = b;
+                break;
+            }
+        }
+        return bot;
+    }
+
+
+    public static void saveOrRemoveAllBot() {
+        if (HorizonConfig.fakeplayerSupport && HorizonConfig.fakeplayerResident) {
+            JsonObject fakePlayerList = new JsonObject();
+            bots.forEach(bot -> fakePlayerList.add(bot.createState.realName, BotUtil.saveBot(bot)));
+            File file = MinecraftServer.getServer().getWorldPath(LevelResource.ROOT).resolve("fake_player.horizon.json").toFile();
+            if (!file.isFile()) {
+                try {
+                    file.createNewFile();
+
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+            }
+            try (BufferedWriter bfw = Files.newBufferedWriter(file.toPath(), StandardCharsets.UTF_8)) {
+                bfw.write(new Gson().toJson(fakePlayerList));
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        } else {
+            removeAllBot();
+        }
+    }
+
+
+    public static void loadAllBot() {
+        if (HorizonConfig.fakeplayerSupport && HorizonConfig.fakeplayerResident) {
+            JsonObject fakePlayerList = new JsonObject();
+            File file = MinecraftServer.getServer().getWorldPath(LevelResource.ROOT).resolve("fake_player.leaves.json").toFile();
+            if (!file.isFile()) {
+                return;
+            }
+            try (BufferedReader bfr = Files.newBufferedReader(file.toPath(), StandardCharsets.UTF_8)) {
+                fakePlayerList = new Gson().fromJson(bfr, JsonObject.class);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+            for (Map.Entry<String, JsonElement> entry : fakePlayerList.entrySet()) {
+                BotUtil.loadBot(entry);
+            }
+            file.delete();
+        }
+
+    }
+
+
+    public static boolean removeAllBot() {
+        Iterator<ServerBot> iterator = bots.iterator();
+        while (iterator.hasNext()) {
+            ServerBot bot = iterator.next();
+            bot.die(bot.damageSources().fellOutOfWorld());
+        }
+        return true;
+    }
+
+
+    public static List<ServerBot> getBots() {
+        return bots;
+    }
+
+
+    public static class CustomGameProfile extends GameProfile {
+        public CustomGameProfile(UUID uuid, String name, String[] skin) {
+            super(uuid, name);
+            setSkin(skin);
+        }
+        public void setSkin(String[] skin) {
+            if (skin != null) {
+                getProperties().put("textures", new Property("textures", skin[0], skin[1]));
+            }
+        }
+    }
+
+
+    public static class BotCreateState {
+
+        public Location loc;
+
+        public String[] skin;
+
+        public String skinName;
+
+        private String realName;
+
+        private String name;
+
+        public BotCreateState(Location loc, String realName, String skinName) {
+            this.loc = loc;
+            this.skinName = skinName;
+            this.setRealName(realName);
+        }
+
+
+        public BotCreateState(Location loc, String name, String realName, String skinName, String[] skin) {
+            this.loc = loc;
+            this.skinName = skinName;
+            this.skin = skin;
+            this.realName = realName;
+            this.name = name;
+        }
+
+
+        public ServerBot createSync() {
+            return createBot(this);
+        }
+
+
+        public void createAsync(Consumer<ServerBot> consumer) {
+            Bukkit.getScheduler().runTaskAsynchronously(CraftScheduler.MINECRAFT, () -> {
+                if (skinName != null) {
+                    this.skin = MojangAPI.getSkin(skinName);
+                }
+
+                Bukkit.getScheduler().runTask(CraftScheduler.MINECRAFT, () -> {
+                    ServerBot bot = createBot(this);
+                    if (bot != null && consumer != null) {
+                        consumer.accept(bot);
+                    }
+                });
+            });
+        }
+
+
+        public void setName(String name) {
+            this.name = name;
+        }
+
+
+        public void setRealName(String realName) {
+            this.realName = realName;
+            this.name = HorizonConfig.fakeplayerPrefix + realName + HorizonConfig.fakeplayerSuffix;
+        }
+
+
+        public String getName() {
+            return name;
+        }
+
+
+        public String getRealName() {
+            return realName;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/horizonmc/horizon/bot/ServerBotGameMode.java b/src/main/java/dev/horizonmc/horizon/bot/ServerBotGameMode.java
new file mode 100644
index 0000000000000000000000000000000000000000..a8c1de99d11a8c9e235e8594a4d0d64c9e4eca39
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/ServerBotGameMode.java
@@ -0,0 +1,130 @@
+package dev.horizonmc.horizon.bot;
+
+import net.kyori.adventure.text.Component;
+import net.minecraft.core.BlockPos;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.level.ServerPlayerGameMode;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.InteractionResult;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.context.UseOnContext;
+import net.minecraft.world.level.GameType;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.BlockHitResult;
+import org.bukkit.event.player.PlayerGameModeChangeEvent;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class ServerBotGameMode extends ServerPlayerGameMode {
+
+    public ServerBotGameMode(ServerBot bot) {
+        super(bot);
+        super.setGameModeForPlayer(GameType.SURVIVAL, null);
+    }
+
+    @Override
+    public boolean changeGameModeForPlayer(@NotNull GameType gameMode) {
+        return false;
+    }
+
+    @Nullable
+    @Override
+    public PlayerGameModeChangeEvent changeGameModeForPlayer(@NotNull GameType gameMode, PlayerGameModeChangeEvent.@NotNull Cause cause, @Nullable Component cancelMessage) {
+        return null;
+    }
+
+    @Override
+    protected void setGameModeForPlayer(@NotNull GameType gameMode, @Nullable GameType previousGameMode) {
+    }
+
+    @Override
+    public void tick() {
+    }
+
+    @Override
+    public void destroyAndAck(@NotNull BlockPos pos, int sequence, @NotNull String reason) {
+        this.destroyBlock(pos);
+    }
+
+    @Override
+    public boolean destroyBlock(@NotNull BlockPos pos) {
+        BlockState iblockdata = this.level.getBlockState(pos);
+        BlockEntity tileentity = this.level.getBlockEntity(pos);
+        Block block = iblockdata.getBlock();
+
+        if (this.player.blockActionRestricted(this.level, pos, this.getGameModeForPlayer())) {
+            return false;
+        } else {
+            this.level.captureDrops = null;
+            BlockState iblockdata1 = block.playerWillDestroy(this.level, pos, iblockdata, this.player);
+            boolean flag = this.level.removeBlock(pos, false);
+
+            if (flag) {
+                block.destroy(this.level, pos, iblockdata1);
+            }
+
+            ItemStack itemstack = this.player.getMainHandItem();
+            ItemStack itemstack1 = itemstack.copy();
+
+            boolean flag1 = this.player.hasCorrectToolForDrops(iblockdata1);
+
+            itemstack.mineBlock(this.level, iblockdata1, pos, this.player);
+            if (flag && flag1) {
+                Block.dropResources(iblockdata1, this.level, pos, tileentity, this.player, itemstack1, true);
+            }
+
+            if (flag) {
+                iblockdata.getBlock().popExperience(this.level, pos, block.getExpDrop(iblockdata, this.level, pos, itemstack, true), this.player);
+            }
+
+            return true;
+        }
+    }
+
+    @NotNull
+    @Override
+    public InteractionResult useItemOn(@NotNull ServerPlayer player, Level world, @NotNull ItemStack stack, @NotNull InteractionHand hand, BlockHitResult hitResult) {
+        BlockPos blockposition = hitResult.getBlockPos();
+        BlockState iblockdata = world.getBlockState(blockposition);
+        InteractionResult enuminteractionresult = InteractionResult.PASS;
+
+        if (!iblockdata.getBlock().isEnabled(world.enabledFeatures())) {
+            return InteractionResult.FAIL;
+        }
+
+        if (player.getCooldowns().isOnCooldown(stack.getItem())) {
+            return InteractionResult.PASS;
+        }
+
+        this.firedInteract = true;
+        this.interactResult = false;
+        this.interactPosition = blockposition.immutable();
+        this.interactHand = hand;
+        this.interactItemStack = stack.copy();
+
+        boolean flag = !player.getMainHandItem().isEmpty() || !player.getOffhandItem().isEmpty();
+        boolean flag1 = player.isSecondaryUseActive() && flag;
+
+        if (!flag1) {
+            enuminteractionresult = iblockdata.use(world, player, hand, hitResult);
+
+            if (enuminteractionresult.consumesAction()) {
+                return enuminteractionresult;
+            }
+        }
+
+        if (!stack.isEmpty() && enuminteractionresult != InteractionResult.SUCCESS && !this.interactResult) {
+            UseOnContext itemactioncontext = new UseOnContext(player, hand, hitResult);
+            return stack.useOn(itemactioncontext);
+        }
+        return enuminteractionresult;
+    }
+
+    @Override
+    public void setLevel(@NotNull ServerLevel world) {
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/bot/agent/Actions.java b/src/main/java/dev/horizonmc/horizon/bot/agent/Actions.java
new file mode 100644
index 0000000000000000000000000000000000000000..8dbc215e6327562eaa377fa9bec6abb5ddf5d571
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/agent/Actions.java
@@ -0,0 +1,65 @@
+package dev.horizonmc.horizon.bot.agent;
+
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+public class Actions {
+
+    private static final Map<String, BotAction> actions = new HashMap<>();
+
+    public static void registerAll() {
+        register(new AttackAction());
+        register(new BreakBlockAction());
+        register(new DropAction());
+        register(new JumpAction());
+        register(new RotateAction());
+        register(new SneakAction());
+        register(new StopAction());
+        register(new UseItemAction());
+        register(new UseItemOnAction());
+        register(new UseItemToAction());
+        register(new LookAction());
+        register(new FishAction());
+        register(new AttackSelfAction());
+        register(new SwimAction());
+        register(new UseItemOffHandAction());
+        register(new UseItemOnOffhandAction());
+        register(new UseItemToOffhandAction());
+    }
+
+    public static boolean register(@NotNull BotAction action) {
+        if (!actions.containsKey(action.getName())) {
+            actions.put(action.getName(), action);
+            return true;
+        }
+        return false;
+    }
+
+    public static boolean unregister(@NotNull String name) {
+        if (actions.containsKey(name)) {
+            actions.remove(name);
+            return true;
+        }
+        return false;
+    }
+
+    @NotNull
+    @Contract(pure = true)
+    public static Collection<BotAction> getAll() {
+        return actions.values();
+    }
+
+    @NotNull
+    public static Set<String> getNames() {
+        return actions.keySet();
+    }
+
+    public static BotAction getForName(String name) {
+        return actions.get(name);
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/bot/agent/AttackAction.java b/src/main/java/dev/horizonmc/horizon/bot/agent/AttackAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..db8cb70d6225058413cc01ac69a1a1c695977543
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/agent/AttackAction.java
@@ -0,0 +1,35 @@
+package dev.horizonmc.horizon.bot.agent;
+
+import dev.horizonmc.horizon.bot.ServerBot;
+import dev.horizonmc.horizon.commands.CommandArgument;
+import dev.horizonmc.horizon.commands.CommandArgumentResult;
+import dev.horizonmc.horizon.commands.CommandArgumentType;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.phys.EntityHitResult;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+public class AttackAction extends BotAction {
+
+    public AttackAction() {
+        super("attack", new CommandArgument(CommandArgumentType.INTEGER, CommandArgumentType.INTEGER));
+        setTabComplete(0, List.of("[TickDelay]"));
+        setTabComplete(1, List.of("[DoNumber]"));
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return new AttackAction().setTickDelay(result.readInt(20)).setNumber(result.readInt(-1));
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        EntityHitResult result = bot.getTargetEntity(3);
+        if (result != null) {
+            bot.attack(result.getEntity());
+            return true;
+        }
+        return false;
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/bot/agent/AttackSelfAction.java b/src/main/java/dev/horizonmc/horizon/bot/agent/AttackSelfAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..0954fa1fd37fce91ffaa0cba90ea8fdc4c4c14a0
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/agent/AttackSelfAction.java
@@ -0,0 +1,38 @@
+package dev.horizonmc.horizon.bot.agent;
+
+import com.google.common.base.Predicates;
+import dev.horizonmc.horizon.bot.ServerBot;
+import dev.horizonmc.horizon.commands.CommandArgument;
+import dev.horizonmc.horizon.commands.CommandArgumentResult;
+import dev.horizonmc.horizon.commands.CommandArgumentType;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Entity;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+public class AttackSelfAction extends BotAction {
+
+    public AttackSelfAction() {
+        super("attack_self", new CommandArgument(CommandArgumentType.INTEGER, CommandArgumentType.INTEGER));
+        setTabComplete(0, List.of("[TickDelay]"));
+        setTabComplete(1, List.of("[DoNumber]"));
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return new AttackSelfAction().setTickDelay(result.readInt(20)).setNumber(result.readInt(-1));
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        List<Entity> entities = bot.level().getEntities((Entity) null, bot.getBoundingBox(), (entity -> entity != bot));
+        if (!entities.isEmpty()) {
+            for (Entity entity : entities) {
+                bot.attack(entity);
+                return true;
+            }
+        }
+        return false;
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/bot/agent/BotAction.java b/src/main/java/dev/horizonmc/horizon/bot/agent/BotAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..5888b2a33c82b098e21b3cb3da51315e0aa4220c
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/agent/BotAction.java
@@ -0,0 +1,93 @@
+package dev.horizonmc.horizon.bot.agent;
+
+import dev.horizonmc.horizon.bot.ServerBot;
+import dev.horizonmc.horizon.commands.CommandArgument;
+import dev.horizonmc.horizon.commands.CommandArgumentResult;
+import net.minecraft.server.level.ServerPlayer;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+public abstract class BotAction {
+
+    private final String name;
+    private final CommandArgument argument;
+
+    private boolean cancel;
+    private int tickDelay;
+    private int number;
+
+    private int needWaitTick;
+    private int canDoNumber;
+
+    public BotAction(String name, CommandArgument argument) {
+        this.name = name;
+        this.argument = argument;
+
+        this.cancel = false;
+        this.tickDelay = 20;
+        this.number = -1;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public int getTickDelay() {
+        return tickDelay;
+    }
+
+    public int getNumber() {
+        return number;
+    }
+
+    public boolean isCancel() {
+        return cancel;
+    }
+
+    public BotAction setTickDelay(int tickDelay) {
+        this.tickDelay = Math.max(0, tickDelay);
+        return this;
+    }
+
+    public BotAction setTabComplete(int index, List<String> list) {
+        argument.setTabComplete(index, list);
+        return this;
+    }
+
+    public BotAction setNumber(int number) {
+        this.number = Math.max(-1, number);
+        return this;
+    }
+
+    public void setCancel(boolean cancel) {
+        this.cancel = cancel;
+    }
+
+    public void init() {
+        this.needWaitTick = 0;
+        this.canDoNumber = this.getNumber();
+        this.setCancel(false);
+    }
+
+    public void tryTick(ServerBot bot) {
+        if (canDoNumber == 0) {
+            this.setCancel(true);
+            return;
+        }
+        if (needWaitTick-- <= 0) {
+            if (this.doTick(bot)) {
+                canDoNumber--;
+                needWaitTick = this.getTickDelay();
+            }
+        }
+    }
+
+    public CommandArgument getArgument() {
+        return argument;
+    }
+
+    public abstract BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result);
+
+    public abstract boolean doTick(@NotNull ServerBot bot);
+}
diff --git a/src/main/java/dev/horizonmc/horizon/bot/agent/BreakBlockAction.java b/src/main/java/dev/horizonmc/horizon/bot/agent/BreakBlockAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..f544e5b8c697b14e916ea537cf2d37029dbe9b44
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/agent/BreakBlockAction.java
@@ -0,0 +1,104 @@
+package dev.horizonmc.horizon.bot.agent;
+
+import dev.horizonmc.horizon.bot.ServerBot;
+import dev.horizonmc.horizon.commands.CommandArgument;
+import dev.horizonmc.horizon.commands.CommandArgumentResult;
+import dev.horizonmc.horizon.commands.CommandArgumentType;
+import net.minecraft.core.BlockPos;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.level.block.state.BlockState;
+import org.bukkit.block.Block;
+import org.bukkit.craftbukkit.block.CraftBlock;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+public class BreakBlockAction extends BotAction {
+
+    public BreakBlockAction() {
+        super("break", new CommandArgument(CommandArgumentType.INTEGER, CommandArgumentType.INTEGER));
+        setTabComplete(0, List.of("[TickDelay]"));
+        setTabComplete(1, List.of("[DoNumber]"));
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return new BreakBlockAction().setTickDelay(result.readInt(20)).setNumber(result.readInt(-1));
+    }
+
+    @Override
+    public BotAction setTickDelay(int tickDelay) {
+        super.setTickDelay(0);
+        this.delay = tickDelay;
+        return this;
+    }
+
+    private int delay = 0;
+    private int nowDelay = 0;
+
+    private BlockPos lastPos = null;
+    private int destroyProgressTime = 0;
+    private int lastSentState = -1;
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        if (nowDelay > 0) {
+            nowDelay--;
+            return false;
+        }
+
+        Block block = bot.getBukkitEntity().getTargetBlockExact(5);
+        if (block != null) {
+            BlockPos pos = ((CraftBlock) block).getPosition();
+
+            if (lastPos == null || !lastPos.equals(pos)) {
+                lastPos = pos;
+                destroyProgressTime = 0;
+                lastSentState = -1;
+            }
+
+            BlockState iblockdata = bot.level().getBlockState(pos);
+            if (!iblockdata.isAir()) {
+                bot.swing(InteractionHand.MAIN_HAND);
+
+                if (iblockdata.getDestroyProgress(bot, bot.level(), pos) >= 1.0F) {
+                    bot.gameMode.destroyAndAck(pos, 0, "insta mine");
+                    bot.level().destroyBlockProgress(bot.getId(), pos, -1);
+                    bot.updateItemInHand(InteractionHand.MAIN_HAND);
+                    finalBreak();
+                    return true;
+                }
+
+                float damage = this.incrementDestroyProgress(bot, iblockdata, pos);
+                if (damage >= 1.0F) {
+                    bot.gameMode.destroyAndAck(pos, 0, "destroyed");
+                    bot.level().destroyBlockProgress(bot.getId(), pos, -1);
+                    bot.updateItemInHand(InteractionHand.MAIN_HAND);
+                    finalBreak();
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    private void finalBreak() {
+        lastPos = null;
+        destroyProgressTime = 0;
+        lastSentState = -1;
+        nowDelay = delay;
+    }
+
+    private float incrementDestroyProgress(ServerBot bot, @NotNull BlockState state, BlockPos pos) {
+        float f = state.getDestroyProgress(bot, bot.level(), pos) * (float) (destroyProgressTime);
+        int k = (int) (f * 10.0F);
+
+        if (k != lastSentState) {
+            bot.level().destroyBlockProgress(bot.getId(), pos, k);
+            lastSentState = k;
+        }
+
+        return f;
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/bot/agent/CraftCustomBotAction.java b/src/main/java/dev/horizonmc/horizon/bot/agent/CraftCustomBotAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..29dcd71bb9f265d3674859fc73970aaf3e8ab2c3
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/agent/CraftCustomBotAction.java
@@ -0,0 +1,47 @@
+package dev.horizonmc.horizon.bot.agent;
+
+import dev.horizonmc.horizon.bot.ServerBot;
+import dev.horizonmc.horizon.commands.CommandArgument;
+import dev.horizonmc.horizon.commands.CommandArgumentResult;
+import dev.horizonmc.horizon.entity.botaction.CustomBotAction;
+import net.minecraft.server.level.ServerPlayer;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+
+public class CraftCustomBotAction extends BotAction {
+
+    private final CustomBotAction realAction;
+
+    public CraftCustomBotAction(String name, @NotNull CustomBotAction realAction) {
+        super(name, new CommandArgument().setAllTabComplete(realAction.getTabComplete()));
+        this.realAction = realAction;
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    public BotAction getNew(@NotNull Player player, String[] args) {
+        CustomBotAction newRealAction = realAction.getNew(player, args);
+        if (newRealAction != null) {
+            return new CraftCustomBotAction(getName(), newRealAction);
+        }
+        return null;
+    }
+
+    @Override
+    public int getNumber() {
+        return realAction.getNumber();
+    }
+
+    @Override
+    public int getTickDelay() {
+        return realAction.getTickDelay();
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        return realAction.doTick(bot.getBukkitPlayer());
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/bot/agent/DropAction.java b/src/main/java/dev/horizonmc/horizon/bot/agent/DropAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..de25a6108e118d3765f66cc7a65c4daea1214c27
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/agent/DropAction.java
@@ -0,0 +1,25 @@
+package dev.horizonmc.horizon.bot.agent;
+
+import dev.horizonmc.horizon.bot.ServerBot;
+import dev.horizonmc.horizon.commands.CommandArgument;
+import dev.horizonmc.horizon.commands.CommandArgumentResult;
+import net.minecraft.server.level.ServerPlayer;
+import org.jetbrains.annotations.NotNull;
+
+public class DropAction extends BotAction {
+
+    public DropAction() {
+        super("drop", new CommandArgument());
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return this.setTickDelay(0).setNumber(1);
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        bot.dropAll();
+        return true;
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/bot/agent/FishAction.java b/src/main/java/dev/horizonmc/horizon/bot/agent/FishAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..65de7eba3d886f8f115bde5148c1cfd35b98b618
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/agent/FishAction.java
@@ -0,0 +1,69 @@
+package dev.horizonmc.horizon.bot.agent;
+
+import dev.horizonmc.horizon.bot.ServerBot;
+import dev.horizonmc.horizon.commands.CommandArgument;
+import dev.horizonmc.horizon.commands.CommandArgumentResult;
+import dev.horizonmc.horizon.commands.CommandArgumentType;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.entity.projectile.FishingHook;
+import net.minecraft.world.item.FishingRodItem;
+import net.minecraft.world.item.ItemStack;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+public class FishAction extends BotAction {
+
+    public FishAction() {
+        super("fish", new CommandArgument(CommandArgumentType.INTEGER, CommandArgumentType.INTEGER));
+        setTabComplete(0, List.of("[TickDelay]"));
+        setTabComplete(1, List.of("[DoNumber]"));
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return new FishAction().setTickDelay(result.readInt(20)).setNumber(result.readInt(-1));
+    }
+
+    @Override
+    public BotAction setTickDelay(int tickDelay) {
+        super.setTickDelay(0);
+        this.delay = tickDelay;
+        return this;
+    }
+
+    private int delay = 0;
+    private int nowDelay = 0;
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        if (nowDelay > 0) {
+            nowDelay--;
+            return false;
+        }
+
+        ItemStack mainHand = bot.getMainHandItem();
+        if (mainHand == ItemStack.EMPTY || mainHand.getItem().getClass() != FishingRodItem.class) {
+            return false;
+        }
+
+        FishingHook fishingHook = bot.fishing;
+        if (fishingHook != null) {
+            if (fishingHook.currentState == FishingHook.FishHookState.HOOKED_IN_ENTITY) {
+                mainHand.use(bot.level(), bot, InteractionHand.MAIN_HAND);
+                nowDelay = 20;
+                return false;
+            }
+            if (fishingHook.nibble > 0) {
+                mainHand.use(bot.level(), bot, InteractionHand.MAIN_HAND);
+                nowDelay = delay;
+                return true;
+            }
+        } else {
+            mainHand.use(bot.level(), bot, InteractionHand.MAIN_HAND);
+        }
+
+        return false;
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/bot/agent/JumpAction.java b/src/main/java/dev/horizonmc/horizon/bot/agent/JumpAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..1c65e55de5d3161d5e5e41e880caf11411c79628
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/agent/JumpAction.java
@@ -0,0 +1,34 @@
+package dev.horizonmc.horizon.bot.agent;
+
+import dev.horizonmc.horizon.bot.ServerBot;
+import dev.horizonmc.horizon.commands.CommandArgument;
+import dev.horizonmc.horizon.commands.CommandArgumentResult;
+import dev.horizonmc.horizon.commands.CommandArgumentType;
+import net.minecraft.server.level.ServerPlayer;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+public class JumpAction extends BotAction {
+
+    public JumpAction() {
+        super("jump", new CommandArgument(CommandArgumentType.INTEGER, CommandArgumentType.INTEGER));
+        setTabComplete(0, List.of("[TickDelay]"));
+        setTabComplete(1, List.of("[DoNumber]"));
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return new JumpAction().setTickDelay(result.readInt(20)).setNumber(result.readInt(-1));
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        if (bot.onGround()) {
+            bot.jumpFromGround();
+            return true;
+        } else {
+            return false;
+        }
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/bot/agent/LookAction.java b/src/main/java/dev/horizonmc/horizon/bot/agent/LookAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..4d048131f05c1c710acca1d6d2d00d4142652d5c
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/agent/LookAction.java
@@ -0,0 +1,48 @@
+package dev.horizonmc.horizon.bot.agent;
+
+import dev.horizonmc.horizon.bot.ServerBot;
+import dev.horizonmc.horizon.commands.CommandArgument;
+import dev.horizonmc.horizon.commands.CommandArgumentResult;
+import dev.horizonmc.horizon.commands.CommandArgumentType;
+import net.minecraft.server.level.ServerPlayer;
+import org.bukkit.util.Vector;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+public class LookAction extends BotAction {
+
+    public LookAction() {
+        super("look", new CommandArgument(CommandArgumentType.DOUBLE, CommandArgumentType.DOUBLE, CommandArgumentType.DOUBLE));
+        setTabComplete(0, List.of("<X>"));
+        setTabComplete(1, List.of("<Y>"));
+        setTabComplete(2, List.of("<Z>"));
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        Vector pos = result.readVector();
+        if (pos != null) {
+            return new LookAction().setPos(pos).setTickDelay(0).setNumber(1);
+        } else {
+            return null;
+        }
+    }
+
+    private Vector pos;
+
+    public LookAction setPos(Vector pos) {
+        if (pos != null) {
+            this.pos = pos;
+            return this;
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        bot.look(pos.subtract(bot.getLocation().toVector()), false);
+        return true;
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/bot/agent/RotateAction.java b/src/main/java/dev/horizonmc/horizon/bot/agent/RotateAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..458475aa1da518468c14c50f82fea0bc5592ffda
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/agent/RotateAction.java
@@ -0,0 +1,32 @@
+package dev.horizonmc.horizon.bot.agent;
+
+import dev.horizonmc.horizon.bot.ServerBot;
+import dev.horizonmc.horizon.commands.CommandArgument;
+import dev.horizonmc.horizon.commands.CommandArgumentResult;
+import net.minecraft.server.level.ServerPlayer;
+import org.jetbrains.annotations.NotNull;
+
+public class RotateAction extends BotAction {
+
+    public RotateAction() {
+        super("rotate", new CommandArgument());
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return new RotateAction().setPlayer(player).setTickDelay(0).setNumber(1);
+    }
+
+    private ServerPlayer player;
+
+    public RotateAction setPlayer(ServerPlayer player) {
+        this.player = player;
+        return this;
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        bot.faceLocation(player.getBukkitEntity().getLocation());
+        return true;
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/bot/agent/SneakAction.java b/src/main/java/dev/horizonmc/horizon/bot/agent/SneakAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..efec7a3f4c288d95233d972910d2caa2f563c9fb
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/agent/SneakAction.java
@@ -0,0 +1,26 @@
+package dev.horizonmc.horizon.bot.agent;
+
+import dev.horizonmc.horizon.bot.ServerBot;
+import dev.horizonmc.horizon.commands.CommandArgument;
+import dev.horizonmc.horizon.commands.CommandArgumentResult;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Pose;
+import org.jetbrains.annotations.NotNull;
+
+public class SneakAction extends BotAction {
+
+    public SneakAction() {
+        super("sneak", new CommandArgument());
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return this.setTickDelay(0).setNumber(1);
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        bot.setShiftKeyDown(!bot.isShiftKeyDown());
+        return true;
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/bot/agent/StopAction.java b/src/main/java/dev/horizonmc/horizon/bot/agent/StopAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..cd833dacb24fa6438a194e9f352acbdbfcd036ff
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/agent/StopAction.java
@@ -0,0 +1,25 @@
+package dev.horizonmc.horizon.bot.agent;
+
+import dev.horizonmc.horizon.bot.ServerBot;
+import dev.horizonmc.horizon.commands.CommandArgument;
+import dev.horizonmc.horizon.commands.CommandArgumentResult;
+import net.minecraft.server.level.ServerPlayer;
+import org.jetbrains.annotations.NotNull;
+
+public class StopAction extends BotAction {
+
+    public StopAction() {
+        super("stop", new CommandArgument());
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return this.setTickDelay(0).setNumber(0);
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        this.setCancel(true);
+        return true;
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/bot/agent/SwimAction.java b/src/main/java/dev/horizonmc/horizon/bot/agent/SwimAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..8f65c72fedab13b8f614e6c19fb9db79b6a6318b
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/agent/SwimAction.java
@@ -0,0 +1,25 @@
+package dev.horizonmc.horizon.bot.agent;
+
+import dev.horizonmc.horizon.bot.ServerBot;
+import dev.horizonmc.horizon.commands.CommandArgument;
+import dev.horizonmc.horizon.commands.CommandArgumentResult;
+import net.minecraft.server.level.ServerPlayer;
+import org.jetbrains.annotations.NotNull;
+
+public class SwimAction extends BotAction {
+
+    public SwimAction() {
+        super("swim", new CommandArgument());
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return this.setTickDelay(0).setNumber(1);
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        bot.waterSwim = !bot.waterSwim;
+        return true;
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/bot/agent/UseItemAction.java b/src/main/java/dev/horizonmc/horizon/bot/agent/UseItemAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..c5342918c9a3954b91784df9d4065de35a7d700c
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/agent/UseItemAction.java
@@ -0,0 +1,32 @@
+package dev.horizonmc.horizon.bot.agent;
+
+import dev.horizonmc.horizon.bot.ServerBot;
+import dev.horizonmc.horizon.commands.CommandArgument;
+import dev.horizonmc.horizon.commands.CommandArgumentResult;
+import dev.horizonmc.horizon.commands.CommandArgumentType;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.InteractionHand;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+public class UseItemAction extends BotAction {
+
+    public UseItemAction() {
+        super("use", new CommandArgument(CommandArgumentType.INTEGER, CommandArgumentType.INTEGER));
+        setTabComplete(0, List.of("[TickDelay]"));
+        setTabComplete(1, List.of("[DoNumber]"));
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return new UseItemAction().setTickDelay(result.readInt(20)).setNumber(result.readInt(-1));
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        bot.swing(InteractionHand.MAIN_HAND);
+        bot.updateItemInHand(InteractionHand.MAIN_HAND);
+        return bot.gameMode.useItem(bot, bot.level(), bot.getItemInHand(InteractionHand.MAIN_HAND), InteractionHand.MAIN_HAND).consumesAction();
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/bot/agent/UseItemOffHandAction.java b/src/main/java/dev/horizonmc/horizon/bot/agent/UseItemOffHandAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..b86946123dc83bb12e0b0e452e028df9fffcf4c1
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/agent/UseItemOffHandAction.java
@@ -0,0 +1,32 @@
+package dev.horizonmc.horizon.bot.agent;
+
+import dev.horizonmc.horizon.bot.ServerBot;
+import dev.horizonmc.horizon.commands.CommandArgument;
+import dev.horizonmc.horizon.commands.CommandArgumentResult;
+import dev.horizonmc.horizon.commands.CommandArgumentType;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.InteractionHand;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+public class UseItemOffHandAction extends BotAction {
+
+    public UseItemOffHandAction() {
+        super("use_offhand", new CommandArgument(CommandArgumentType.INTEGER, CommandArgumentType.INTEGER));
+        setTabComplete(0, List.of("[TickDelay]"));
+        setTabComplete(1, List.of("[DoNumber]"));
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return new UseItemOffHandAction().setTickDelay(result.readInt(20)).setNumber(result.readInt(-1));
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        bot.swing(InteractionHand.OFF_HAND);
+        bot.updateItemInHand(InteractionHand.OFF_HAND);
+        return bot.gameMode.useItem(bot, bot.level(), bot.getItemInHand(InteractionHand.OFF_HAND), InteractionHand.OFF_HAND).consumesAction();
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/bot/agent/UseItemOnAction.java b/src/main/java/dev/horizonmc/horizon/bot/agent/UseItemOnAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..1f2db7a27458388a6c9dba1cc3c0ce92e39c7339
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/agent/UseItemOnAction.java
@@ -0,0 +1,55 @@
+package dev.horizonmc.horizon.bot.agent;
+
+import dev.horizonmc.horizon.bot.ServerBot;
+import dev.horizonmc.horizon.commands.CommandArgument;
+import dev.horizonmc.horizon.commands.CommandArgumentResult;
+import dev.horizonmc.horizon.commands.CommandArgumentType;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.level.ClipContext;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.entity.TrappedChestBlockEntity;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.HitResult;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.scheduler.CraftScheduler;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+public class UseItemOnAction extends BotAction {
+
+    public UseItemOnAction() {
+        super("use_on", new CommandArgument(CommandArgumentType.INTEGER, CommandArgumentType.INTEGER));
+        setTabComplete(0, List.of("[TickDelay]"));
+        setTabComplete(1, List.of("[DoNumber]"));
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return new UseItemOnAction().setTickDelay(result.readInt(20)).setNumber(result.readInt(-1));
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        HitResult result = bot.getRayTrace(5, ClipContext.Fluid.NONE);
+        if (result instanceof BlockHitResult blockHitResult) {
+            BlockState state = bot.serverLevel().getBlockState(blockHitResult.getBlockPos());
+            bot.swing(InteractionHand.MAIN_HAND);
+            if (state.getBlock() == Blocks.TRAPPED_CHEST) {
+                BlockEntity entity = bot.serverLevel().getBlockEntity(blockHitResult.getBlockPos());
+                if (entity instanceof TrappedChestBlockEntity chestBlockEntity) {
+                    chestBlockEntity.startOpen(bot);
+                    Bukkit.getScheduler().runTaskLater(CraftScheduler.MINECRAFT, () -> chestBlockEntity.stopOpen(bot), 1);
+                    return true;
+                }
+            } else {
+                bot.updateItemInHand(InteractionHand.MAIN_HAND);
+                return bot.gameMode.useItemOn(bot, bot.level(), bot.getItemInHand(InteractionHand.MAIN_HAND), InteractionHand.MAIN_HAND, (BlockHitResult) result).consumesAction();
+            }
+        }
+        return false;
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/bot/agent/UseItemOnOffhandAction.java b/src/main/java/dev/horizonmc/horizon/bot/agent/UseItemOnOffhandAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..f4036c069ab54678dbb01f73d418fc2f7d53b33e
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/agent/UseItemOnOffhandAction.java
@@ -0,0 +1,55 @@
+package dev.horizonmc.horizon.bot.agent;
+
+import dev.horizonmc.horizon.bot.ServerBot;
+import dev.horizonmc.horizon.commands.CommandArgument;
+import dev.horizonmc.horizon.commands.CommandArgumentResult;
+import dev.horizonmc.horizon.commands.CommandArgumentType;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.level.ClipContext;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.entity.TrappedChestBlockEntity;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.HitResult;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.scheduler.CraftScheduler;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+public class UseItemOnOffhandAction extends BotAction {
+
+    public UseItemOnOffhandAction() {
+        super("use_on_offhand", new CommandArgument(CommandArgumentType.INTEGER, CommandArgumentType.INTEGER));
+        setTabComplete(0, List.of("[TickDelay]"));
+        setTabComplete(1, List.of("[DoNumber]"));
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return new UseItemOnOffhandAction().setTickDelay(result.readInt(20)).setNumber(result.readInt(-1));
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        HitResult result = bot.getRayTrace(5, ClipContext.Fluid.NONE);
+        if (result instanceof BlockHitResult blockHitResult) {
+            BlockState state = bot.serverLevel().getBlockState(blockHitResult.getBlockPos());
+            bot.swing(InteractionHand.OFF_HAND);
+            if (state.getBlock() == Blocks.TRAPPED_CHEST) {
+                BlockEntity entity = bot.serverLevel().getBlockEntity(blockHitResult.getBlockPos());
+                if (entity instanceof TrappedChestBlockEntity chestBlockEntity) {
+                    chestBlockEntity.startOpen(bot);
+                    Bukkit.getScheduler().runTaskLater(CraftScheduler.MINECRAFT, () -> chestBlockEntity.stopOpen(bot), 1);
+                    return true;
+                }
+            } else {
+                bot.updateItemInHand(InteractionHand.OFF_HAND);
+                return bot.gameMode.useItemOn(bot, bot.level(), bot.getItemInHand(InteractionHand.OFF_HAND), InteractionHand.OFF_HAND, (BlockHitResult) result).consumesAction();
+            }
+        }
+        return false;
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/bot/agent/UseItemToAction.java b/src/main/java/dev/horizonmc/horizon/bot/agent/UseItemToAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..e06a48662e640297d51ab19611f74d60eed45629
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/agent/UseItemToAction.java
@@ -0,0 +1,37 @@
+package dev.horizonmc.horizon.bot.agent;
+
+import dev.horizonmc.horizon.bot.ServerBot;
+import dev.horizonmc.horizon.commands.CommandArgument;
+import dev.horizonmc.horizon.commands.CommandArgumentResult;
+import dev.horizonmc.horizon.commands.CommandArgumentType;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.phys.EntityHitResult;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+public class UseItemToAction extends BotAction {
+
+    public UseItemToAction() {
+        super("use_to", new CommandArgument(CommandArgumentType.INTEGER, CommandArgumentType.INTEGER));
+        setTabComplete(0, List.of("[TickDelay]"));
+        setTabComplete(1, List.of("[DoNumber]"));
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return new UseItemToAction().setTickDelay(result.readInt(20)).setNumber(result.readInt(-1));
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        EntityHitResult result = bot.getTargetEntity(3);
+        if (result != null) {
+            bot.swing(InteractionHand.MAIN_HAND);
+            bot.updateItemInHand(InteractionHand.MAIN_HAND);
+            return bot.interactOn(result.getEntity(), InteractionHand.MAIN_HAND).consumesAction();
+        }
+        return false;
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/bot/agent/UseItemToOffhandAction.java b/src/main/java/dev/horizonmc/horizon/bot/agent/UseItemToOffhandAction.java
new file mode 100644
index 0000000000000000000000000000000000000000..b875183fc93e4c793c93a1e42398a2f5f04b2deb
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/bot/agent/UseItemToOffhandAction.java
@@ -0,0 +1,37 @@
+package dev.horizonmc.horizon.bot.agent;
+
+import dev.horizonmc.horizon.bot.ServerBot;
+import dev.horizonmc.horizon.commands.CommandArgument;
+import dev.horizonmc.horizon.commands.CommandArgumentResult;
+import dev.horizonmc.horizon.commands.CommandArgumentType;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.phys.EntityHitResult;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+public class UseItemToOffhandAction extends BotAction {
+
+    public UseItemToOffhandAction() {
+        super("use_to_offhand", new CommandArgument(CommandArgumentType.INTEGER, CommandArgumentType.INTEGER));
+        setTabComplete(0, List.of("[TickDelay]"));
+        setTabComplete(1, List.of("[DoNumber]"));
+    }
+
+    @Override
+    public BotAction getNew(@NotNull ServerPlayer player, @NotNull CommandArgumentResult result) {
+        return new UseItemToOffhandAction().setTickDelay(result.readInt(20)).setNumber(result.readInt(-1));
+    }
+
+    @Override
+    public boolean doTick(@NotNull ServerBot bot) {
+        EntityHitResult result = bot.getTargetEntity(3);
+        if (result != null) {
+            bot.swing(InteractionHand.OFF_HAND);
+            bot.updateItemInHand(InteractionHand.OFF_HAND);
+            return bot.interactOn(result.getEntity(), InteractionHand.OFF_HAND).consumesAction();
+        }
+        return false;
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/commands/CommandArgument.java b/src/main/java/dev/horizonmc/horizon/commands/CommandArgument.java
index 349266b0cad5bb2b85b4714c1d1cf98b60e49881..e4f5c32d9a04d450dffd643093f393432c21b70d 100644
--- a/src/main/java/dev/horizonmc/horizon/commands/CommandArgument.java
+++ b/src/main/java/dev/horizonmc/horizon/commands/CommandArgument.java
@@ -31,6 +31,12 @@ public class CommandArgument {
         return this;
     }
 
+    public CommandArgument setAllTabComplete(List<List<String>> tabComplete) {
+        this.tabComplete.clear();
+        this.tabComplete.addAll(tabComplete);
+        return this;
+    }
+
     public CommandArgumentResult parse(int index, String @NotNull [] args) {
         Object[] result = new Object[argumentTypes.size()];
         Arrays.fill(result, null);
diff --git a/src/main/java/dev/horizonmc/horizon/entity/CraftBot.java b/src/main/java/dev/horizonmc/horizon/entity/CraftBot.java
new file mode 100644
index 0000000000000000000000000000000000000000..779d0efae69f6bd5fa94127734fd206b35cc9063
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/entity/CraftBot.java
@@ -0,0 +1,67 @@
+package dev.horizonmc.horizon.entity;
+
+import dev.horizonmc.horizon.bot.ServerBot;
+import dev.horizonmc.horizon.bot.agent.Actions;
+import dev.horizonmc.horizon.bot.agent.BotAction;
+import dev.horizonmc.horizon.entity.botaction.HorizonBotAction;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.UUID;
+
+public class CraftBot extends CraftPlayer implements Bot {
+
+    public CraftBot(CraftServer server, ServerBot entity) {
+        super(server, entity);
+    }
+
+    @Override
+    public String getSkinName() {
+        return getHandle().createState.skinName;
+    }
+
+    @Override
+    public @NotNull String getRealName() {
+        return getHandle().createState.getRealName();
+    }
+
+    @Override
+    public @Nullable UUID getCreatePlayerUUID() {
+        return getHandle().createPlayer;
+    }
+
+    @Override
+    public boolean setBotAction(@NotNull String action, @NotNull Player player, @NotNull String[] args) {
+        BotAction botAction = Actions.getForName(action);
+        if (botAction != null) {
+            BotAction newAction = botAction.getNew(((CraftPlayer) player).getHandle(), botAction.getArgument().parse(0, args));
+            if (newAction != null) {
+                getHandle().setBotAction(newAction);
+                return true;
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public boolean setBotAction(@NotNull HorizonBotAction action, @NotNull Player player, @NotNull String[] args) {
+        return setBotAction(action.getName(), player, args);
+    }
+
+    @Override
+    public ServerBot getHandle() {
+        return (ServerBot) entity;
+    }
+
+    public void setHandle(final ServerBot entity) {
+        super.setHandle(entity);
+    }
+
+    @Override
+    public String toString() {
+        return "CraftBot{" + "name=" + getName() + '}';
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/entity/CraftBotManager.java b/src/main/java/dev/horizonmc/horizon/entity/CraftBotManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..62085e6f875d80711b590a70044a276f2798fc0e
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/entity/CraftBotManager.java
@@ -0,0 +1,93 @@
+package dev.horizonmc.horizon.entity;
+
+import com.google.common.base.Function;
+import com.google.common.collect.Lists;
+import dev.horizonmc.horizon.bot.ServerBot;
+import dev.horizonmc.horizon.bot.agent.Actions;
+import dev.horizonmc.horizon.bot.agent.CraftCustomBotAction;
+import dev.horizonmc.horizon.entity.botaction.CustomBotAction;
+import org.bukkit.Location;
+import org.bukkit.util.Consumer;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.UUID;
+
+public class CraftBotManager implements BotManager {
+
+    private final Collection<Bot> botViews = Collections.unmodifiableList(Lists.transform(ServerBot.getBots(), new Function<ServerBot, CraftBot>() {
+        @Override
+        public CraftBot apply(ServerBot bot) {
+            return bot.getBukkitEntity();
+        }
+    }));
+
+    @Override
+    public @Nullable Bot getBot(@NotNull UUID uuid) {
+        return ServerBot.getBot(uuid).getBukkitPlayer();
+    }
+
+    @Override
+    public @Nullable Bot getBot(@NotNull String name) {
+        return ServerBot.getBot(name).getBukkitPlayer();
+    }
+
+    @Override
+    public @Nullable Bot createBot(@NotNull String name, @NotNull String realName, @Nullable String[] skin, @Nullable String skinName, @NotNull Location location) {
+        ServerBot bot = new ServerBot.BotCreateState(location, name, realName, skinName, skin).createSync();
+        if (bot != null) {
+            return bot.getBukkitPlayer();
+        }
+        return null;
+    }
+
+    @Override
+    public void createBot(@NotNull String name, @Nullable String skinName, @NotNull Location location, Consumer<Bot> consumer) {
+        new ServerBot.BotCreateState(location, name, skinName).createAsync((serverBot -> {
+            consumer.accept(serverBot.getBukkitPlayer());
+        }));
+    }
+
+    @Override
+    public void removeBot(@NotNull String name) {
+        ServerBot bot = ServerBot.getBot(name);
+        if (bot != null) {
+            bot.die(bot.damageSources().fellOutOfWorld());
+        }
+    }
+
+    @Override
+    public void removeBot(@NotNull UUID uuid) {
+        ServerBot bot = ServerBot.getBot(uuid);
+        if (bot != null) {
+            bot.die(bot.damageSources().fellOutOfWorld());
+        }
+    }
+
+    @Override
+    public void removeAllBots() {
+        ServerBot.removeAllBot();
+    }
+
+    @Override
+    public void saveOrRemoveAllBots() {
+        ServerBot.saveOrRemoveAllBot();
+    }
+
+    @Override
+    public Collection<Bot> getBots() {
+        return botViews;
+    }
+
+    @Override
+    public boolean registerCustomBotAction(String name, CustomBotAction action) {
+        return Actions.register(new CraftCustomBotAction(name, action));
+    }
+
+    @Override
+    public boolean unregisterCustomBotAction(String name) {
+        return Actions.unregister(name);
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/util/MathUtils.java b/src/main/java/dev/horizonmc/horizon/util/MathUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..f3b336f44d0b2f9ab27a41978a6e170dabb893e7
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/util/MathUtils.java
@@ -0,0 +1,75 @@
+package dev.horizonmc.horizon.util;
+
+import org.bukkit.util.NumberConversions;
+import org.bukkit.util.Vector;
+
+import java.util.regex.Pattern;
+
+public class MathUtils {
+    // Lag ?
+    public static void clean(Vector vector) {
+        if (!NumberConversions.isFinite(vector.getX())) vector.setX(0);
+        if (!NumberConversions.isFinite(vector.getY())) vector.setY(0);
+        if (!NumberConversions.isFinite(vector.getZ())) vector.setZ(0);
+    }
+
+    private static final Pattern numericPattern = Pattern.compile("^-?[1-9]\\d*$|^0$");
+
+    public static boolean isNumeric(String str) {
+        return numericPattern.matcher(str).matches();
+    }
+
+    public static float[] fetchYawPitch(Vector dir) {
+        double x = dir.getX();
+        double z = dir.getZ();
+
+        float[] out = new float[2];
+
+        if (x == 0.0D && z == 0.0D) {
+            out[1] = (float) (dir.getY() > 0.0D ? -90 : 90);
+        } else {
+            double theta = Math.atan2(-x, z);
+            out[0] = (float) Math.toDegrees((theta + 6.283185307179586D) % 6.283185307179586D);
+
+            double x2 = NumberConversions.square(x);
+            double z2 = NumberConversions.square(z);
+            double xz = Math.sqrt(x2 + z2);
+            out[1] = (float) Math.toDegrees(Math.atan(-dir.getY() / xz));
+        }
+
+        return out;
+    }
+
+    public static float fetchPitch(Vector dir) {
+        double x = dir.getX();
+        double z = dir.getZ();
+
+        float result;
+
+        if (x == 0.0D && z == 0.0D) {
+            result = (float) (dir.getY() > 0.0D ? -90 : 90);
+        } else {
+            double x2 = NumberConversions.square(x);
+            double z2 = NumberConversions.square(z);
+            double xz = Math.sqrt(x2 + z2);
+            result = (float) Math.toDegrees(Math.atan(-dir.getY() / xz));
+        }
+
+        return result;
+    }
+
+    public static Vector getDirection(double rotX, double rotY) {
+        Vector vector = new Vector();
+
+        rotX = Math.toRadians(rotX);
+        rotY = Math.toRadians(rotY);
+
+        double xz = Math.abs(Math.cos(rotY));
+
+        vector.setX(-Math.sin(rotX) * xz);
+        vector.setZ(Math.cos(rotX) * xz);
+        vector.setY(-Math.sin(rotY));
+
+        return vector;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
index fd1318aa26e9ba136180d9e26a50c685a427f30f..7f68494f351d84f324d94458ef8b0e2d972fe8c6 100644
--- a/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
+++ b/src/main/java/io/papermc/paper/plugin/manager/PaperEventManager.java
@@ -41,6 +41,12 @@ class PaperEventManager {
             throw new IllegalStateException(event.getEventName() + " may only be triggered synchronously.");
         }
 
+        // Horizon start - skip bot
+        if (event instanceof org.bukkit.event.player.PlayerEvent playerEvent && playerEvent.getPlayer() instanceof dev.horizonmc.horizon.entity.Bot) {
+            return;
+        }
+        // Horizon end - skip bot
+
         HandlerList handlers = event.getHandlers();
         RegisteredListener[] listeners = handlers.getRegisteredListeners();
 
diff --git a/src/main/java/net/minecraft/advancements/critereon/SimpleCriterionTrigger.java b/src/main/java/net/minecraft/advancements/critereon/SimpleCriterionTrigger.java
index 35772110e9318df46a2729dbc0b5879b290011b7..762fac22d091962fb3e92b30fc4f8a6ceef8edb0 100644
--- a/src/main/java/net/minecraft/advancements/critereon/SimpleCriterionTrigger.java
+++ b/src/main/java/net/minecraft/advancements/critereon/SimpleCriterionTrigger.java
@@ -39,6 +39,7 @@ public abstract class SimpleCriterionTrigger<T extends SimpleCriterionTrigger.Si
     }
 
     protected void trigger(ServerPlayer player, Predicate<T> predicate) {
+        if (player instanceof dev.horizonmc.horizon.bot.ServerBot) return; // Horizon - bot skip
         PlayerAdvancements playerAdvancements = player.getAdvancements();
         Set<CriterionTrigger.Listener<T>> set = (Set) playerAdvancements.criterionData.get(this); // Paper - fix AdvancementDataPlayer leak
         if (set != null && !set.isEmpty()) {
diff --git a/src/main/java/net/minecraft/network/Connection.java b/src/main/java/net/minecraft/network/Connection.java
index 9e31954212b1d6162dca2fbc91d373e908560335..d47e149bbe3adcffdc5e5b419f5fa909b42a331f 100644
--- a/src/main/java/net/minecraft/network/Connection.java
+++ b/src/main/java/net/minecraft/network/Connection.java
@@ -340,6 +340,14 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         }
     }
 
+    // Horizon start - fakeplayer
+    public void setListenerForce(PacketListener packetListener) {
+        Validate.notNull(packetListener, "packetListener");
+        this.packetListener = packetListener;
+        this.disconnectListener = null;
+    }
+    // Horizon end - fakeplayer
+
     public void setListenerForServerboundHandshake(PacketListener packetListener) {
         if (this.packetListener != null) {
             throw new IllegalStateException("Listener already set");
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 25dda7c1a0858f731afb7778b09aa2502ddd7ce1..8b8e1ac96ce717927d0a1810866871c31839bc0e 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -671,6 +671,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
         // Paper end - Configurable player collision
 
+        dev.horizonmc.horizon.bot.ServerBot.loadAllBot(); // Horizon - load resident bot
         dev.horizonmc.horizon.util.TicketHelper.tryToLoadTickets(); // Horizon
 
         this.server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.POSTWORLD);
@@ -974,6 +975,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         MinecraftServer.LOGGER.info("Stopping server");
         Commands.COMMAND_SENDING_POOL.shutdownNow(); // Paper - Perf: Async command map building; Shutdown and don't bother finishing
+        dev.horizonmc.horizon.bot.ServerBot.saveOrRemoveAllBot(); // Horizon - save or remove bot
         // Purpur start
         if (upnp) {
             if (dev.omega24.upnp4j.UPnP4J.close(this.getPort(), dev.omega24.upnp4j.util.Protocol.TCP)) {
diff --git a/src/main/java/net/minecraft/server/PlayerAdvancements.java b/src/main/java/net/minecraft/server/PlayerAdvancements.java
index 32f7c86698ac34f67e488cd5ea2d3f0986896076..2a473e9f3c122ec177754cfef0f4a44d6cba55f2 100644
--- a/src/main/java/net/minecraft/server/PlayerAdvancements.java
+++ b/src/main/java/net/minecraft/server/PlayerAdvancements.java
@@ -225,11 +225,16 @@ public class PlayerAdvancements {
     }
 
     public boolean award(AdvancementHolder advancement, String criterionName) {
-        // Leaves start - spectator don't get advancement
+        // Horizon start - bot can't get advancement
+        if (player instanceof dev.horizonmc.horizon.bot.ServerBot) {
+            return false;
+        }
+        // Horizon end - bot can't get advancement
+        // Horizon start - spectator don't get advancement
         if (HorizonConfig.spectatorDontGetAdvancement && player.gameMode.getGameModeForPlayer() == GameType.SPECTATOR) {
             return false;
         }
-        // Leaves end - spectator don't get advancement
+        // Horizon end - spectator don't get advancement
         boolean flag = false;
         AdvancementProgress advancementprogress = this.getOrStartProgress(advancement);
         boolean flag1 = advancementprogress.isDone();
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index 6cfd03bfbfd9887b3cad1e457e206c1fea7ea3b5..e390ad530464a706a53ca7b7641bec013dfb1faf 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -1395,6 +1395,13 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             org.spigotmc.AsyncCatcher.catchOp("player tracker clear"); // Spigot
             if (this.seenBy.remove(player.connection)) {
                 this.serverEntity.removePairing(player);
+                // Horizon start - render bot
+                if (entity instanceof dev.horizonmc.horizon.bot.ServerBot bot) {
+                    if (bot.alwaysSendData) {
+                        bot.sendFakeData(player.connection, false);
+                    }
+                }
+                // Horizon end - render bot
             }
 
         }
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index 305b90d10a499e9731f5178433fb10207e428091..38dd5f4371662105ece197e733cee8e665853a08 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -17,6 +17,8 @@ import java.util.OptionalInt;
 import java.util.Set;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
+
+import dev.horizonmc.horizon.bot.ServerBot;
 import net.minecraft.BlockUtil;
 import net.minecraft.ChatFormatting;
 import net.minecraft.CrashReport;
@@ -197,7 +199,7 @@ public class ServerPlayer extends Player {
     private static final int FLY_STAT_RECORDING_SPEED = 25;
     public ServerGamePacketListenerImpl connection;
     public final MinecraftServer server;
-    public final ServerPlayerGameMode gameMode;
+    public ServerPlayerGameMode gameMode; // Horizon - final -> null
     private final PlayerAdvancements advancements;
     private final ServerStatsCounter stats;
     private float lastRecordedHealthAndAbsorption = Float.MIN_VALUE;
@@ -739,16 +741,20 @@ public class ServerPlayer extends Player {
             --this.invulnerableTime;
         }
 
-        // Paper start - Configurable container update tick rate
-        if (--containerUpdateDelay <= 0) {
-            this.containerMenu.broadcastChanges();
-            containerUpdateDelay = this.level().paperConfig().tickRates.containerUpdate;
-        }
-        // Paper end - Configurable container update tick rate
-        if (!this.level().isClientSide && this.containerMenu != this.inventoryMenu && (this.isImmobile() || !this.containerMenu.stillValid(this))) { // Paper - Prevent opening inventories when frozen
-            this.closeContainer(org.bukkit.event.inventory.InventoryCloseEvent.Reason.CANT_USE); // Paper - Inventory close reason
-            this.containerMenu = this.inventoryMenu;
+        // Horizon start - skip bot
+        if (!(this instanceof ServerBot)) {
+            // Paper start - Configurable container update tick rate
+            if (--containerUpdateDelay <= 0) {
+                this.containerMenu.broadcastChanges();
+                containerUpdateDelay = this.level().paperConfig().tickRates.containerUpdate;
+            }
+            // Paper end - Configurable container update tick rate
+            if (!this.level().isClientSide && this.containerMenu != this.inventoryMenu && (this.isImmobile() || !this.containerMenu.stillValid(this))) { // Paper - Prevent opening inventories when frozen
+                this.closeContainer(org.bukkit.event.inventory.InventoryCloseEvent.Reason.CANT_USE); // Paper - Inventory close reason
+                this.containerMenu = this.inventoryMenu;
+            }
         }
+        // Horizon stop - skip bot
 
         Entity entity = this.getCamera();
 
@@ -764,7 +770,7 @@ public class ServerPlayer extends Player {
             }
         }
 
-        CriteriaTriggers.TICK.trigger(this);
+        if (!(this instanceof ServerBot)) CriteriaTriggers.TICK.trigger(this); // Horizon - skip bot
         if (this.levitationStartPos != null) {
             CriteriaTriggers.LEVITATION.trigger(this, this.levitationStartPos, this.tickCount - this.levitationStartTime);
         }
@@ -966,7 +972,7 @@ public class ServerPlayer extends Player {
         List<DefaultDrop> loot = new java.util.ArrayList<>(this.getInventory().getContainerSize()); // Paper - Restore vanilla drops behavior
         boolean keepInventory = this.level().getGameRules().getBoolean(GameRules.RULE_KEEPINVENTORY) || this.isSpectator();
 
-        if (!keepInventory) {
+        if (!keepInventory || this instanceof ServerBot) { // Horizon - skip bot
             for (ItemStack item : this.getInventory().getContents()) {
                 if (!item.isEmpty() && !EnchantmentHelper.hasVanishingCurse(item)) {
                     loot.add(new DefaultDrop(item, stack -> this.drop(stack, true, false, false))); // Paper - Restore vanilla drops behavior; drop function taken from Inventory#dropAll (don't fire drop event)
@@ -1303,6 +1309,13 @@ public class ServerPlayer extends Player {
                 this.lastSentHealth = -1.0F;
                 this.lastSentFood = -1;
 
+                // Horizon start - bot support
+                if (dev.horizonmc.horizon.HorizonConfig.fakeplayerSupport) {
+                    ServerBot.getBots().forEach(bot1 ->
+                            bot1.sendFakeDataIfNeed(this, true)); // Horizon - render bot
+                }
+                // Horizon end - bot support
+
                 // CraftBukkit start
                 PlayerChangedWorldEvent changeEvent = new PlayerChangedWorldEvent(this.getBukkitEntity(), worldserver1.getWorld());
                 this.level().getCraftServer().getPluginManager().callEvent(changeEvent);
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 2595e39cc1d999c2721c00ee4acd1038f4fc1608..77f4cf8d93cb2ee6d312ae834031def70f9bad31 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -297,7 +297,13 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
     public ServerGamePacketListenerImpl(MinecraftServer server, Connection connection, ServerPlayer player, CommonListenerCookie clientData) {
         super(server, connection, clientData, player); // CraftBukkit
         this.chunkSender = new PlayerChunkSender(connection.isMemoryConnection());
-        connection.setListener(this);
+        // Horizon start - fakeplayer
+        if (player instanceof dev.horizonmc.horizon.bot.ServerBot) {
+            connection.setListenerForce(this);
+        } else {
+            connection.setListener(this);
+        }
+        // Horizon end - fakeplayer
         this.player = player;
         player.connection = this;
         player.getTextFilter().join();
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index a28218cbcc095f68f18f1d8bb7446050e0ee74c6..1754daa6ffd28fa257b13c3dc7cbbaab815a7ff9 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -26,6 +26,7 @@ import java.util.function.Predicate;
 import javax.annotation.Nullable;
 
 import dev.horizonmc.horizon.HorizonConfig;
+import dev.horizonmc.horizon.bot.ServerBot;
 import net.minecraft.ChatFormatting;
 import net.minecraft.FileUtil;
 import net.minecraft.commands.CommandSourceStack;
@@ -351,6 +352,21 @@ public abstract class PlayerList {
 
         dev.horizonmc.horizon.protocol.core.HorizonProtocolManager.handlePlayerJoin(player); // Horizon - protocol
 
+        // Horizon start - bot support
+        if (dev.horizonmc.horizon.HorizonConfig.fakeplayerSupport) {
+            ServerBot bot = ServerBot.getBot(player.getScoreboardName().toLowerCase(java.util.Locale.ROOT));
+            if (bot != null) {
+                bot.die(bot.damageSources().fellOutOfWorld()); // Horizon - remove bot with the same name
+                this.playersByName.put(player.getScoreboardName().toLowerCase(java.util.Locale.ROOT), player);
+                this.playersByUUID.put(player.getUUID(), player);
+            }
+            ServerBot.getBots().forEach(bot1 -> {
+                bot1.sendPlayerInfo(player);
+                bot1.sendFakeDataIfNeed(player, true);
+            }); // Horizon - render bot
+        }
+        // Horizon end - bot support
+
         final net.kyori.adventure.text.Component jm = playerJoinEvent.joinMessage();
 
         if (jm != null && !jm.equals(net.kyori.adventure.text.Component.empty())) { // Paper - Adventure
@@ -871,6 +887,13 @@ public abstract class PlayerList {
         boolean isLocAltered = false; // Paper - Fix SPIGOT-5989
         // Paper end - Add PlayerPostRespawnEvent
 
+        // Horizon start - bot support
+        if (dev.horizonmc.horizon.HorizonConfig.fakeplayerSupport) {
+            ServerBot.getBots().forEach(bot1 ->
+                    bot1.sendFakeDataIfNeed(entityplayer1, true)); // Horizon - render bot
+        }
+        // Horizon end - bot support
+
         // CraftBukkit start - fire PlayerRespawnEvent
         if (location == null) {
             // boolean isBedSpawn = false; // Paper - Add PlayerPostRespawnEvent; moved up
@@ -1134,11 +1157,16 @@ public abstract class PlayerList {
     }
 
     public String[] getPlayerNamesArray() {
-        String[] astring = new String[this.players.size()];
+        String[] astring = new String[this.players.size() + ServerBot.getBots().size()]; // Horizon - fakeplayer support
 
         for (int i = 0; i < this.players.size(); ++i) {
             astring[i] = ((ServerPlayer) this.players.get(i)).getGameProfile().getName();
         }
+        // Horizon start - fakeplayer support
+        for (int i = this.players.size(); i < astring.length; ++i) {
+            astring[i] = ((ServerPlayer) ServerBot.getBots().get(i - this.players.size())).getGameProfile().getName();
+        }
+        // Horizon end - fakeplayer support
 
         return astring;
     }
@@ -1641,4 +1669,16 @@ public abstract class PlayerList {
     public boolean isAllowCheatsForAllPlayers() {
         return this.allowCheatsForAllPlayers;
     }
+
+    // Horizon start - fakeplayer support
+    public void addNewBot(ServerBot bot) {
+        playersByName.put(bot.getScoreboardName().toLowerCase(java.util.Locale.ROOT), bot);
+        playersByUUID.put(bot.getUUID(), bot);
+    }
+
+    public void removeBot(ServerBot bot) {
+        playersByName.remove(bot.getScoreboardName().toLowerCase(java.util.Locale.ROOT));
+        playersByUUID.remove(bot.getUUID());
+    }
+    // Horizon end - fakeplayer support
 }
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 0b079f3e99709ae63b9720206d28a0c32ab6190a..3109d7ace833fc94bbadc40f806e5b8268efe913 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -1498,7 +1498,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource, S
         return offsetFactor;
     }
 
-    private Vec3 collide(Vec3 movement) {
+    public Vec3 collide(Vec3 movement) { // Horizon - private -> public
         // Paper start - optimise collisions
         final boolean xZero = movement.x == 0.0;
         final boolean yZero = movement.y == 0.0;
diff --git a/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java b/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
index 91497f5e6c07fcf1b05eca6846c51e1a15ed3bc0..6fb05be0e48fe6fcb6a782ac85b7bdc0d35fb429 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
@@ -62,7 +62,7 @@ public class FishingHook extends Projectile {
     public static final EntityDataAccessor<Integer> DATA_HOOKED_ENTITY = SynchedEntityData.defineId(FishingHook.class, EntityDataSerializers.INT);
     private static final EntityDataAccessor<Boolean> DATA_BITING = SynchedEntityData.defineId(FishingHook.class, EntityDataSerializers.BOOLEAN);
     private int life;
-    private int nibble;
+    public int nibble; // Horizon - private -> public
     public int timeUntilLured;
     private int timeUntilHooked;
     private float fishAngle;
diff --git a/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java b/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
index fa185a8145843edf44fc0aeedb6c36b2b13263ae..bd9f46ccf418f811647d2650a334f39eb42b3f30 100644
--- a/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
+++ b/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
@@ -407,6 +407,8 @@ public abstract class AbstractContainerMenu {
         ItemStack itemstack1;
         int l;
 
+        if (!doClickCheck(slotIndex, button, actionType, player)) return; // Horizon - doClick check
+
         if (actionType == ClickType.QUICK_CRAFT) {
             int i1 = this.quickcraftStatus;
 
@@ -681,6 +683,23 @@ public abstract class AbstractContainerMenu {
 
     }
 
+    // Horizon start - doClick check
+    private boolean doClickCheck(int slotIndex, int button, ClickType actionType, Player player) {
+        if (slotIndex < 0) {
+            return true;
+        }
+
+        Slot slot = getSlot(slotIndex);
+        ItemStack itemStack = slot.getItem();
+        if (itemStack.getTag() != null) {
+            if (itemStack.getTag().get("Horizon.Gui.Placeholder") != null) {
+                return !itemStack.getTag().getBoolean("Horizon.Gui.Placeholder");
+            }
+        }
+        return true;
+    }
+    // Horizon end - doClick check
+
     private boolean tryItemClickBehaviourOverride(Player player, ClickAction clickType, Slot slot, ItemStack stack, ItemStack cursorStack) {
         FeatureFlagSet featureflagset = player.level().enabledFeatures();
 
diff --git a/src/main/java/net/minecraft/world/level/levelgen/PhantomSpawner.java b/src/main/java/net/minecraft/world/level/levelgen/PhantomSpawner.java
index 0847aef56d8608cb1403485f231f30b2527f35ab..b6f195067ab2dcc8b39af8186a8b110f665641ee 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/PhantomSpawner.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/PhantomSpawner.java
@@ -68,6 +68,11 @@ public class PhantomSpawner implements CustomSpawner {
                                     ServerStatsCounter serverstatisticmanager = entityplayer.getStats();
                                     int j = Mth.clamp(serverstatisticmanager.getValue(Stats.CUSTOM.get(Stats.TIME_SINCE_REST)), 1, Integer.MAX_VALUE);
                                     boolean flag2 = true;
+                                    // Horizon start - fakeplayer spawn
+                                    if (entityplayer instanceof dev.horizonmc.horizon.bot.ServerBot bot && bot.spawnPhantom) {
+                                        j = bot.notSleepTicks;
+                                    }
+                                    // Horizon end - fakeplayer spawn
 
                                     if (randomsource.nextInt(j) >= world.paperConfig().entities.behavior.playerInsomniaStartTicks) { // Paper - Ability to control player's insomnia and phantoms
                                         BlockPos blockposition1 = blockposition.above(20 + randomsource.nextInt(15)).east(-10 + randomsource.nextInt(21)).south(-10 + randomsource.nextInt(21));
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index a0ac37699aad1a81963451e8dbabe61abcfb1ebf..7c23153814f032d1cc8f4ec1c05d8e5ea885c7d7 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -14,6 +14,7 @@ import com.mojang.brigadier.tree.CommandNode;
 import com.mojang.brigadier.tree.LiteralCommandNode;
 import com.mojang.serialization.Dynamic;
 import com.mojang.serialization.Lifecycle;
+import dev.horizonmc.horizon.entity.CraftBotManager;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
 import java.awt.image.BufferedImage;
 import java.io.ByteArrayOutputStream;
@@ -307,6 +308,7 @@ public final class CraftServer implements Server {
     public static Exception excessiveVelEx; // Paper - Velocity warnings
     private final io.papermc.paper.logging.SysoutCatcher sysoutCatcher = new io.papermc.paper.logging.SysoutCatcher(); // Paper
     private final CraftPotionBrewer potionBrewer = new CraftPotionBrewer(); // Paper - Custom Potion Mixes
+    private final CraftBotManager botManager = new CraftBotManager();
 
     // Paper start - Folia region threading API
     private final io.papermc.paper.threadedregions.scheduler.FallbackRegionScheduler regionizedScheduler = new io.papermc.paper.threadedregions.scheduler.FallbackRegionScheduler();
@@ -3365,4 +3367,11 @@ public final class CraftServer implements Server {
         return getServer().lagging;
     }
     // Purpur end
+
+    // Horizon start - Bot API
+    @Override
+    public CraftBotManager getBotManager() {
+        return botManager;
+    }
+    // Horizon end - Bot API
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 7121de7f623b4a57937a9c60c8fc0f4307e538dc..1ed49a2016ce1a2530d56017753a945725e41e6b 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -8,6 +8,9 @@ import com.google.common.collect.Lists;
 import java.util.List;
 import java.util.Set;
 import java.util.UUID;
+
+import dev.horizonmc.horizon.bot.ServerBot;
+import dev.horizonmc.horizon.entity.CraftBot;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.Tag;
 import net.minecraft.network.chat.Component;
@@ -107,6 +110,8 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
             return new CraftHumanEntity(server, (net.minecraft.world.entity.player.Player) entity);
         }
 
+        if (entity instanceof ServerBot) { return new CraftBot(server, (ServerBot) entity); }
+
         // Special case complex part, since there is no extra entity type for them
         if (entity instanceof EnderDragonPart complexPart) {
             if (complexPart.parentMob instanceof EnderDragon) {
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
index c9ffab2a77f5a9428c94a7b755b73940d0d1ba9a..c81d937884ebc9c8462eb42e49d26e743518289d 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
@@ -46,7 +46,7 @@ import org.bukkit.scheduler.BukkitWorker;
  */
 public class CraftScheduler implements BukkitScheduler {
 
-    static Plugin MINECRAFT = new MinecraftInternalPlugin();
+    public static Plugin MINECRAFT = new MinecraftInternalPlugin(); // Horizon - package -> public
     /**
      * The start ID for the counter.
      */
