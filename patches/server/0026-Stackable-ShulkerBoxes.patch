From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: GideonWhite1029 <gideonwhite1029@gmail.com>
Date: Wed, 12 Jun 2024 17:00:23 +0400
Subject: [PATCH] Stackable ShulkerBoxes


diff --git a/src/main/java/dev/horizonmc/horizon/HorizonConfig.java b/src/main/java/dev/horizonmc/horizon/HorizonConfig.java
index 1c647cd4b67771c0a26c74b2c6f1dbf552359008..e9e00ffd148d3cee1580225da6d887d377765faa 100644
--- a/src/main/java/dev/horizonmc/horizon/HorizonConfig.java
+++ b/src/main/java/dev/horizonmc/horizon/HorizonConfig.java
@@ -5,6 +5,7 @@ import dev.horizonmc.horizon.commands.HorizonCommand;
 import dev.horizonmc.horizon.config.ConfigVerify;
 import dev.horizonmc.horizon.config.GlobalConfig;
 import dev.horizonmc.horizon.config.GlobalConfigManager;
+import dev.horizonmc.horizon.util.MathUtils;
 import net.minecraft.server.MinecraftServer;
 import org.bukkit.Bukkit;
 import org.bukkit.command.Command;
@@ -216,4 +217,17 @@ public final class HorizonConfig {
     @GlobalConfig(name = "stick-change-armorstand-arm-status", category = {"utils"})
     public static boolean stickChangeArmorStandArmStatus = false;
 
+    public static int shulkerBoxStackSize = 1;
+    @GlobalConfig(name = "stackable-shulker-boxes", category = "modify", verify = StackableShulkerVerify.class)
+    private static String stackableShulkerBoxes = "false";
+
+    private static class StackableShulkerVerify extends ConfigVerify.StringConfigVerify {
+        @Override
+        public String check(String old, String value) {
+            String realValue = MathUtils.isNumeric(value) ? value : value.equals("true") ? "2" : "1";
+            shulkerBoxStackSize = Integer.parseInt(realValue);
+            return null;
+        }
+    }
+
 }
\ No newline at end of file
diff --git a/src/main/java/dev/horizonmc/horizon/util/ShulkerBoxUtils.java b/src/main/java/dev/horizonmc/horizon/util/ShulkerBoxUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..572077e10c78eaa9de65a0d54aebb4c6c39a1297
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/util/ShulkerBoxUtils.java
@@ -0,0 +1,78 @@
+package dev.horizonmc.horizon.util;
+
+import dev.horizonmc.horizon.HorizonConfig;
+import net.minecraft.core.component.DataComponentMap;
+import net.minecraft.core.component.DataComponentPatch;
+import net.minecraft.core.component.PatchedDataComponentMap;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.world.inventory.Slot;
+import net.minecraft.world.item.BlockItem;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.component.CustomData;
+import net.minecraft.world.level.block.ShulkerBoxBlock;
+import org.jetbrains.annotations.NotNull;
+
+import static net.minecraft.core.component.DataComponents.BLOCK_ENTITY_DATA;
+
+// Powered by fabric-carpet/src/main/java/carpet/helpers/InventoryHelper.java
+public class ShulkerBoxUtils {
+    // From nbt/NbtElement.java createTag()
+    public static final int TAG_END = 0;
+    public static final int TAG_BYTE = 1;
+    public static final int TAG_SHORT = 2;
+    public static final int TAG_INT = 3;
+    public static final int TAG_LONG = 4;
+    public static final int TAG_FLOAT = 5;
+    public static final int TAG_DOUBLE = 6;
+    public static final int TAG_BYTEARRAY = 7;
+    public static final int TAG_STRING = 8;
+    public static final int TAG_LIST = 9;
+    public static final int TAG_COMPOUND = 10;
+    public static final int TAG_INTARRAY = 11;
+    public static final int TAG_LONGARRAY = 12;
+
+    public static boolean cleanUpShulkerBoxTag(@NotNull ItemStack stack) {
+        boolean changed = false;
+        DataComponentMap components = stack.getComponents();
+
+        if (!components.has(BLOCK_ENTITY_DATA)) return false;
+
+        CompoundTag bet = components.get(BLOCK_ENTITY_DATA).copyTag();
+        if (bet.contains("Items", TAG_LIST) && bet.getList("Items", TAG_COMPOUND).isEmpty()) {
+            bet.remove("Items");
+            stack.applyComponents(DataComponentPatch.builder().set(BLOCK_ENTITY_DATA, CustomData.of(bet)).build());
+            changed = true;
+        }
+
+        if (bet.isEmpty() || (bet.size() == 1 && bet.getString("id").equals("minecraft:shulker_box"))) {
+            stack.applyComponents(DataComponentPatch.builder().remove(BLOCK_ENTITY_DATA).build());
+            changed = true;
+        }
+        if (components.isEmpty()) {
+            stack.components = (PatchedDataComponentMap.fromPatch(DataComponentMap.EMPTY, DataComponentPatch.EMPTY));
+            changed = true;
+        }
+        return changed;
+    }
+
+    public static boolean shulkerBoxHasItems(@NotNull ItemStack stack) {
+        DataComponentMap components = stack.getComponents();
+
+        if (!components.has(BLOCK_ENTITY_DATA)) return false;
+
+        CompoundTag bet = components.get(BLOCK_ENTITY_DATA).copyTag();
+        return bet.contains("Items", TAG_LIST) && !bet.getList("Items", TAG_COMPOUND).isEmpty();
+    }
+
+    public static int getItemStackMaxCount(ItemStack stack) {
+        if (HorizonConfig.shulkerBoxStackSize > 1 && stack.getItem() instanceof BlockItem bi &&
+                bi.getBlock() instanceof ShulkerBoxBlock && !dev.horizonmc.horizon.util.ShulkerBoxUtils.shulkerBoxHasItems(stack)) {
+            return HorizonConfig.shulkerBoxStackSize;
+        }
+        return stack.getMaxStackSize();
+    }
+
+    public static boolean isStackable(ItemStack itemStack) {
+        return getItemStackMaxCount(itemStack) > 1 && (!itemStack.isDamageableItem() || !itemStack.isDamaged());
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/world/entity/item/ItemEntity.java b/src/main/java/net/minecraft/world/entity/item/ItemEntity.java
index 0db854f70332d3a256d3190155ac1aaa7523ed6f..348823ef983a2a3229750b82631baa0bbb76fc66 100644
--- a/src/main/java/net/minecraft/world/entity/item/ItemEntity.java
+++ b/src/main/java/net/minecraft/world/entity/item/ItemEntity.java
@@ -24,10 +24,12 @@ import net.minecraft.world.entity.EntityType;
 import net.minecraft.world.entity.MoverType;
 import net.minecraft.world.entity.SlotAccess;
 import net.minecraft.world.entity.TraceableEntity;
+import net.minecraft.world.item.BlockItem;
 import net.minecraft.world.item.Item;
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
 import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.ShulkerBoxBlock;
 import net.minecraft.world.level.gameevent.GameEvent;
 import net.minecraft.world.phys.Vec3;
 // CraftBukkit start
@@ -92,6 +94,13 @@ public class ItemEntity extends Entity implements TraceableEntity {
         // Horizon end
         this.setItem(stack);
         // Paper end - Don't use level random in entity constructors
+        // Leaves start - stackable shulker boxes
+        if (dev.horizonmc.horizon.HorizonConfig.shulkerBoxStackSize > 1) {
+            if (stack.getItem() instanceof BlockItem bi && bi.getBlock() instanceof ShulkerBoxBlock) {
+                dev.horizonmc.horizon.util.ShulkerBoxUtils.cleanUpShulkerBoxTag(stack);
+            }
+        }
+        // Leaves end - stackable shulker boxes
     }
 
     public ItemEntity(Level world, double x, double y, double z, ItemStack stack, double velocityX, double velocityY, double velocityZ) {
@@ -328,10 +337,48 @@ public class ItemEntity extends Entity implements TraceableEntity {
     private boolean isMergable() {
         ItemStack itemstack = this.getItem();
 
-        return this.isAlive() && this.pickupDelay != 32767 && this.age != -32768 && this.age < this.despawnRate && itemstack.getCount() < itemstack.getMaxStackSize(); // Paper - Alternative item-despawn-rate
+        return this.isAlive() && this.pickupDelay != 32767 && this.age != -32768 && this.age < this.despawnRate && itemstack.getCount() < dev.horizonmc.horizon.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack); // Paper - Alternative item-despawn-rate // Horizon - stackable shulker boxes
     }
 
+    // Horizon end - stackable shulker boxes
+    private boolean tryStackShulkerBoxes(ItemEntity other) {
+        ItemStack selfStack = this.getItem();
+        if (dev.horizonmc.horizon.HorizonConfig.shulkerBoxStackSize == 1 || !(selfStack.getItem() instanceof BlockItem bi) || !(bi.getBlock() instanceof ShulkerBoxBlock)) {
+            return false;
+        }
+
+        ItemStack otherStack = other.getItem();
+        if (selfStack.getItem() == otherStack.getItem()
+                && !dev.horizonmc.horizon.util.ShulkerBoxUtils.shulkerBoxHasItems(selfStack)
+                && !dev.horizonmc.horizon.util.ShulkerBoxUtils.shulkerBoxHasItems(otherStack)
+                && Objects.equals(selfStack.getComponents(), otherStack.getComponents()) // empty block entity tags are cleaned up when spawning
+                && selfStack.getCount() != dev.horizonmc.horizon.HorizonConfig.shulkerBoxStackSize) {
+            int amount = Math.min(otherStack.getCount(), dev.horizonmc.horizon.HorizonConfig.shulkerBoxStackSize - selfStack.getCount());
+
+            selfStack.grow(amount);
+            this.setItem(selfStack);
+
+            this.pickupDelay = Math.max(other.pickupDelay, this.pickupDelay);
+            this.age = Math.min(other.getAge(), this.age);
+
+            otherStack.shrink(amount);
+            if (otherStack.isEmpty()) {
+                other.discard();
+            } else {
+                other.setItem(otherStack);
+            }
+            return true;
+        }
+        return false;
+    }
+    // Horizon end - stackable shulker boxes
+
     private void tryToMerge(ItemEntity other) {
+        // Horizon start - stackable shulker boxes
+        if (tryStackShulkerBoxes(other)) {
+            return;
+        }
+        // Horizon end - stackable shulker boxes
         ItemStack itemstack = this.getItem();
         ItemStack itemstack1 = other.getItem();
 
diff --git a/src/main/java/net/minecraft/world/entity/player/Inventory.java b/src/main/java/net/minecraft/world/entity/player/Inventory.java
index ca7fbe4f8c1e1d2fb90095aa35be4dda3029c23e..e560cd41f2d4b908b9718ad170bce6f3667c48d8 100644
--- a/src/main/java/net/minecraft/world/entity/player/Inventory.java
+++ b/src/main/java/net/minecraft/world/entity/player/Inventory.java
@@ -111,7 +111,7 @@ public class Inventory implements Container, Nameable {
     }
 
     private boolean hasRemainingSpaceForItem(ItemStack existingStack, ItemStack stack) {
-        return !existingStack.isEmpty() && existingStack.isStackable() && existingStack.getCount() < this.getMaxStackSize(existingStack) && ItemStack.isSameItemSameComponents(existingStack, stack); // Paper - check if itemstack is stackable first
+        return !existingStack.isEmpty() && dev.horizonmc.horizon.util.ShulkerBoxUtils.isStackable(existingStack) && existingStack.getCount() < dev.horizonmc.horizon.util.ShulkerBoxUtils.getItemStackMaxCount(existingStack) && ItemStack.isSameItemSameComponents(existingStack, stack); // Paper - check if itemstack is stackable first
     }
 
     // CraftBukkit start - Watch method above! :D
@@ -279,7 +279,9 @@ public class Inventory implements Container, Nameable {
             this.setItem(slot, itemstack1);
         }
 
-        int k = this.getMaxStackSize(itemstack1) - itemstack1.getCount();
+        // Horizon start - stackable shulker boxes
+        int k = dev.horizonmc.horizon.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack1) - itemstack1.getCount();
+        // Horizon end - stackable shulker boxes
         int l = Math.min(j, k);
 
         if (l == 0) {
@@ -394,7 +396,7 @@ public class Inventory implements Container, Nameable {
                 }
 
                 if (i != -1) {
-                    int j = stack.getMaxStackSize() - this.getItem(i).getCount();
+                    int j = dev.horizonmc.horizon.util.ShulkerBoxUtils.getItemStackMaxCount(stack) - this.getItem(i).getCount(); // Horizon - stackable shulker boxes
 
                     if (this.add(i, stack.split(j)) && notifiesClient && this.player instanceof ServerPlayer) {
                         ((ServerPlayer) this.player).connection.send(new ClientboundContainerSetSlotPacket(-2, 0, i, this.getItem(i)));
diff --git a/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java b/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
index aa9c40471853a8bfb5170219b922d7041ace8220..98d80777884c96b5e273398f7f9e15966142bd0f 100644
--- a/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
+++ b/src/main/java/net/minecraft/world/inventory/AbstractContainerMenu.java
@@ -457,7 +457,7 @@ public abstract class AbstractContainerMenu {
 
                         if (slot1 != null && AbstractContainerMenu.canItemQuickReplace(slot1, itemstack2, true) && slot1.mayPlace(itemstack2) && (this.quickcraftType == 2 || itemstack2.getCount() >= this.quickcraftSlots.size()) && this.canDragTo(slot1)) {
                             int j1 = slot1.hasItem() ? slot1.getItem().getCount() : 0;
-                            int k1 = Math.min(itemstack1.getMaxStackSize(), slot1.getMaxStackSize(itemstack1));
+                            int k1 = Math.min(dev.horizonmc.horizon.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack1), slot1.getMaxStackSize(itemstack1)); // Horizon - stackable shulker boxes                            int l1 = Math.min(AbstractContainerMenu.getQuickCraftPlaceCount(this.quickcraftSlots, this.quickcraftType, itemstack1) + j1, k1);
                             int l1 = Math.min(AbstractContainerMenu.getQuickCraftPlaceCount(this.quickcraftSlots, this.quickcraftType, itemstack1) + j1, k1);
 
                             l -= l1 - j1;
@@ -576,7 +576,7 @@ public abstract class AbstractContainerMenu {
                                     slot.setByPlayer(itemstack3);
                                 }
                             } else if (ItemStack.isSameItemSameComponents(itemstack, itemstack3)) {
-                                Optional<ItemStack> optional1 = slot.tryRemove(itemstack.getCount(), itemstack3.getMaxStackSize() - itemstack3.getCount(), player);
+                                Optional<ItemStack> optional1 = slot.tryRemove(itemstack.getCount(), dev.horizonmc.horizon.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack3) - itemstack3.getCount(), player);
 
                                 optional1.ifPresent((itemstack4) -> {
                                     itemstack3.grow(itemstack4.getCount());
@@ -646,7 +646,7 @@ public abstract class AbstractContainerMenu {
                         slot2 = (Slot) this.slots.get(slotIndex);
                         if (slot2.hasItem()) {
                             itemstack1 = slot2.getItem();
-                            this.setCarried(itemstack1.copyWithCount(itemstack1.getMaxStackSize()));
+                            this.setCarried(itemstack1.copyWithCount(dev.horizonmc.horizon.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack1))); // Horizon - stackable shulker boxes
                         }
                     } else if (actionType == ClickType.THROW && this.getCarried().isEmpty() && slotIndex >= 0) {
                         slot2 = (Slot) this.slots.get(slotIndex);
@@ -661,13 +661,13 @@ public abstract class AbstractContainerMenu {
                             j2 = button == 0 ? 1 : -1;
 
                             for (i2 = 0; i2 < 2; ++i2) {
-                                for (int k2 = l; k2 >= 0 && k2 < this.slots.size() && itemstack1.getCount() < itemstack1.getMaxStackSize(); k2 += j2) {
+                                for (int k2 = l; k2 >= 0 && k2 < this.slots.size() && itemstack1.getCount() < dev.horizonmc.horizon.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack1); k2 += j2) { // Horizon - stackable shulker boxes
                                     Slot slot3 = (Slot) this.slots.get(k2);
 
                                     if (slot3.hasItem() && AbstractContainerMenu.canItemQuickReplace(slot3, itemstack1, true) && slot3.mayPickup(player) && this.canTakeItemForPickAll(itemstack1, slot3)) {
                                         ItemStack itemstack5 = slot3.getItem();
 
-                                        if (i2 != 0 || itemstack5.getCount() != itemstack5.getMaxStackSize()) {
+                                        if (i2 != 0 || itemstack5.getCount() != dev.horizonmc.horizon.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack5)) {
                                             ItemStack itemstack6 = slot3.safeTake(itemstack5.getCount(), itemstack1.getMaxStackSize() - itemstack1.getCount(), player);
 
                                             itemstack1.grow(itemstack6.getCount());
@@ -806,7 +806,7 @@ public abstract class AbstractContainerMenu {
         ItemStack itemstack1;
         int l;
 
-        if (stack.isStackable()) {
+        if (dev.horizonmc.horizon.util.ShulkerBoxUtils.isStackable(stack)) { // Horizon - stackable shulker boxes
             while (!stack.isEmpty()) {
                 if (fromLast) {
                     if (k < startIndex) {
@@ -825,7 +825,7 @@ public abstract class AbstractContainerMenu {
                 // Paper end - Add PlayerTradeEvent and PlayerPurchaseEvent
                 if (!itemstack1.isEmpty() && ItemStack.isSameItemSameComponents(stack, itemstack1)) {
                     l = itemstack1.getCount() + stack.getCount();
-                    int i1 = slot.getMaxStackSize(itemstack1);
+                    int i1 = dev.horizonmc.horizon.util.ShulkerBoxUtils.getItemStackMaxCount(itemstack1); // Horizon - stackable shulker boxes
 
                     if (l <= i1) {
                         stack.setCount(0);
diff --git a/src/main/java/net/minecraft/world/inventory/Slot.java b/src/main/java/net/minecraft/world/inventory/Slot.java
index c39c773112fb8b534b926f2f2b47fe6fbb69fcb2..73f7bcf1c4c8456f543a37ab0630da40d4eb1b1b 100644
--- a/src/main/java/net/minecraft/world/inventory/Slot.java
+++ b/src/main/java/net/minecraft/world/inventory/Slot.java
@@ -76,7 +76,7 @@ public class Slot {
     }
 
     public int getMaxStackSize(ItemStack stack) {
-        return Math.min(this.getMaxStackSize(), stack.getMaxStackSize());
+        return Math.min(this.getMaxStackSize(), dev.horizonmc.horizon.util.ShulkerBoxUtils.getItemStackMaxCount(stack)); // Horizon - stackable shulker boxes
     }
 
     @Nullable
diff --git a/src/main/java/net/minecraft/world/item/ItemStack.java b/src/main/java/net/minecraft/world/item/ItemStack.java
index 88153ea23d63b24473483b5a9f5d40304dfd9e80..0da3b9430f28a3c6e70addca4dd170615253db48 100644
--- a/src/main/java/net/minecraft/world/item/ItemStack.java
+++ b/src/main/java/net/minecraft/world/item/ItemStack.java
@@ -228,7 +228,7 @@ public final class ItemStack implements DataComponentHolder {
     @Deprecated
     @Nullable
     private Item item;
-    private PatchedDataComponentMap components;
+    public PatchedDataComponentMap components; // Horizon - stackable shulker boxes
     @Nullable
     private Entity entityRepresentation;
 
diff --git a/src/main/java/net/minecraft/world/level/block/AbstractCauldronBlock.java b/src/main/java/net/minecraft/world/level/block/AbstractCauldronBlock.java
index 20f2b575c8131621edea0e75fbf38a9fe20a36c4..fcfe05e5cbc7b9d52f70c813ba55aadd360cbb14 100644
--- a/src/main/java/net/minecraft/world/level/block/AbstractCauldronBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/AbstractCauldronBlock.java
@@ -58,9 +58,27 @@ public abstract class AbstractCauldronBlock extends Block {
         ItemStack stack, BlockState state, Level world, BlockPos pos, Player player, InteractionHand hand, BlockHitResult hit
     ) {
         CauldronInteraction cauldronInteraction = this.interactions.map().get(stack.getItem());
-        return cauldronInteraction.interact(state, world, pos, player, hand, stack);
+        return wrapInteractor(cauldronInteraction, state, world, pos, player, hand, stack);
     }
 
+    // Horizon start - stackable shulker boxes
+    private ItemInteractionResult wrapInteractor(CauldronInteraction cauldronBehavior, BlockState blockState, Level world, BlockPos blockPos, Player playerEntity, InteractionHand hand, ItemStack itemStack) {
+        int count = -1;
+        if (dev.horizonmc.horizon.HorizonConfig.shulkerBoxStackSize > 1 && itemStack.getItem() instanceof net.minecraft.world.item.BlockItem bi &&
+                bi.getBlock() instanceof ShulkerBoxBlock) {
+            count = itemStack.getCount();
+        }
+        ItemInteractionResult result = cauldronBehavior.interact(blockState, world, blockPos, playerEntity, hand, itemStack);
+        if (count > 0 && result.consumesAction()) {
+            ItemStack current = playerEntity.getItemInHand(hand);
+            if (current.getItem() instanceof net.minecraft.world.item.BlockItem bi && bi.getBlock() instanceof ShulkerBoxBlock) {
+                current.setCount(count);
+            }
+        }
+        return result;
+    }
+    // Horizon end - stackable shulker boxes
+
     @Override
     protected VoxelShape getShape(BlockState state, BlockGetter world, BlockPos pos, CollisionContext context) {
         return SHAPE;
diff --git a/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java
index 20ebf55404794ec5f972315af4523bec3c47df69..ec8f1b45ca281b37cf7ec964734aa0d33e418739 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java
@@ -765,9 +765,9 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
             if (itemstack1.isEmpty()) {
                 // Spigot start - SPIGOT-6693, InventorySubcontainer#setItem
                 ItemStack leftover = ItemStack.EMPTY; // Paper - Make hoppers respect inventory max stack size
-                if (!stack.isEmpty() && stack.getCount() > to.getMaxStackSize()) {
+                if (!stack.isEmpty() && (stack.getCount() > to.getMaxStackSize() || stack.getCount() > stack.getMaxStackSize())) { // Horizon - stackable shulker boxes
                     leftover = stack; // Paper - Make hoppers respect inventory max stack size
-                    stack = stack.split(to.getMaxStackSize());
+                    stack = stack.split(Math.min(to.getMaxStackSize(), stack.getMaxStackSize())); // Horizon - stackable shulker boxes
                 }
                 // Spigot end
                 ignoreTileUpdates = true; // Paper - Perf: Optimize Hoppers
