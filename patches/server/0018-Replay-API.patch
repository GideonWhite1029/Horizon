From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: GideonWhite1029 <gideonwhite1029@gmail.com>
Date: Tue, 16 Apr 2024 19:03:37 +0400
Subject: [PATCH] Replay API


diff --git a/src/main/java/dev/horizonmc/horizon/entity/CraftPhotographer.java b/src/main/java/dev/horizonmc/horizon/entity/CraftPhotographer.java
new file mode 100644
index 0000000000000000000000000000000000000000..4de8345f5315e5e2330cf564b0bd5272a5cac8eb
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/entity/CraftPhotographer.java
@@ -0,0 +1,73 @@
+package dev.horizonmc.horizon.entity;
+
+import dev.horizonmc.horizon.replay.ServerPhotographer;
+import net.minecraft.server.level.ServerPlayer;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+
+public class CraftPhotographer extends CraftPlayer implements Photographer {
+
+    public CraftPhotographer(CraftServer server, ServerPhotographer entity) {
+        super(server, entity);
+    }
+
+    @Override
+    public void stopRecording() {
+        this.stopRecording(true);
+    }
+
+    @Override
+    public void stopRecording(boolean async) {
+        this.stopRecording(async, true);
+    }
+
+    @Override
+    public void stopRecording(boolean async, boolean save) {
+        this.getHandle().remove(async, save);
+    }
+
+    @Override
+    public void pauseRecording() {
+        this.getHandle().pauseRecording();
+    }
+
+    @Override
+    public void resumeRecording() {
+        this.getHandle().resumeRecording();
+    }
+
+    @Override
+    public void setRecordFile(@NotNull File file) {
+        this.getHandle().setSaveFile(file);
+    }
+
+    @Override
+    public void setFollowPlayer(@Nullable Player player) {
+        ServerPlayer serverPlayer = player != null ? ((CraftPlayer) player).getHandle() : null;
+        this.getHandle().setFollowPlayer(serverPlayer);
+    }
+
+    @Override
+    public @NotNull String getId() {
+        return this.getHandle().createState.id;
+    }
+
+    @Override
+    public ServerPhotographer getHandle() {
+        return (ServerPhotographer) entity;
+    }
+
+    public void setHandle(final ServerPhotographer entity) {
+        super.setHandle(entity);
+    }
+
+    @Override
+    public String toString() {
+        return "CraftPhotographer{" + "name=" + getName() + '}';
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/entity/CraftPhotographerManager.java b/src/main/java/dev/horizonmc/horizon/entity/CraftPhotographerManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..8a73c01a10b513e9672f64e12ba981c64ae4d3bd
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/entity/CraftPhotographerManager.java
@@ -0,0 +1,84 @@
+package dev.horizonmc.horizon.entity;
+
+import com.google.common.collect.Lists;
+import org.bukkit.Location;
+import org.bukkit.util.Consumer;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import dev.horizonmc.horizon.bot.ServerBot;
+import dev.horizonmc.horizon.replay.BukkitRecorderOption;
+import dev.horizonmc.horizon.replay.RecorderOption;
+import dev.horizonmc.horizon.replay.ServerPhotographer;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.UUID;
+
+public class CraftPhotographerManager implements PhotographerManager {
+
+    private final Collection<Photographer> photographerViews = Collections.unmodifiableList(Lists.transform(ServerPhotographer.getPhotographers(), ServerPhotographer::getBukkitPlayer));
+
+    @Override
+    public @Nullable Photographer getPhotographer(@NotNull UUID uuid) {
+        ServerPhotographer photographer = ServerPhotographer.getPhotographer(uuid);
+        if (photographer != null) {
+            return photographer.getBukkitPlayer();
+        }
+        return null;
+    }
+
+    @Override
+    public @Nullable Photographer getPhotographer(@NotNull String id) {
+        ServerPhotographer photographer = ServerPhotographer.getPhotographer(id);
+        if (photographer != null) {
+            return photographer.getBukkitPlayer();
+        }
+        return null;
+    }
+
+    @Override
+    public @Nullable Photographer createPhotographer(@NotNull String id, @NotNull Location location) {
+        ServerPhotographer photographer = new ServerPhotographer.PhotographerCreateState(location, id, RecorderOption.createDefaultOption()).createSync();
+        if (photographer != null) {
+            return photographer.getBukkitPlayer();
+        }
+        return null;
+    }
+
+    @Override
+    public @Nullable Photographer createPhotographer(@NotNull String id, @NotNull Location location, @NotNull BukkitRecorderOption recorderOption) {
+        ServerPhotographer photographer = new ServerPhotographer.PhotographerCreateState(location, id, RecorderOption.createFromBukkit(recorderOption)).createSync();
+        if (photographer != null) {
+            return photographer.getBukkitPlayer();
+        }
+        return null;
+    }
+
+    @Override
+    public void removePhotographer(@NotNull String id) {
+        ServerPhotographer photographer = ServerPhotographer.getPhotographer(id);
+        if (photographer != null) {
+            photographer.remove(true);
+        }
+    }
+
+    @Override
+    public void removePhotographer(@NotNull UUID uuid) {
+        ServerPhotographer photographer = ServerPhotographer.getPhotographer(uuid);
+        if (photographer != null) {
+            photographer.remove(true);
+        }
+    }
+
+    @Override
+    public void removeAllPhotographers() {
+        for (ServerPhotographer photographer : ServerPhotographer.getPhotographers()) {
+            photographer.remove(true);
+        }
+    }
+
+    @Override
+    public Collection<Photographer> getPhotographers() {
+        return photographerViews;
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/replay/DigestOutputStream.java b/src/main/java/dev/horizonmc/horizon/replay/DigestOutputStream.java
new file mode 100644
index 0000000000000000000000000000000000000000..c6ccc2dceee9da366f3a57748f45578014d002c4
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/replay/DigestOutputStream.java
@@ -0,0 +1,46 @@
+package dev.horizonmc.horizon.replay;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.zip.Checksum;
+
+public class DigestOutputStream extends OutputStream {
+
+    private final Checksum sum;
+    private final OutputStream out;
+
+    public DigestOutputStream(OutputStream out, Checksum sum) {
+        this.out = out;
+        this.sum = sum;
+    }
+
+    @Override
+    public void close() throws IOException {
+        out.close();
+    }
+
+    @Override
+    public void flush() throws IOException {
+        out.flush();
+    }
+
+    @Override
+    public void write(int b) throws IOException {
+        sum.update(b);
+        out.write(b);
+    }
+
+    @Override
+    public void write(byte @NotNull [] b) throws IOException {
+        sum.update(b);
+        out.write(b);
+    }
+
+    @Override
+    public void write(byte @NotNull [] b, int off, int len) throws IOException {
+        sum.update(b, off, len);
+        out.write(b, off, len);
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/replay/RecordMetaData.java b/src/main/java/dev/horizonmc/horizon/replay/RecordMetaData.java
new file mode 100644
index 0000000000000000000000000000000000000000..f551cfcabaa6bce88ae268700d4ed2ac6eb23075
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/replay/RecordMetaData.java
@@ -0,0 +1,23 @@
+package dev.horizonmc.horizon.replay;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.UUID;
+
+public class RecordMetaData {
+
+    public static final int CURRENT_FILE_FORMAT_VERSION = 14;
+
+    public boolean singleplayer = false;
+    public String serverName = "Horizon";
+    public int duration = 0;
+    public long date;
+    public String mcversion;
+    public String fileFormat = "MCPR";
+    public int fileFormatVersion;
+    public int protocol;
+    public String generator;
+    public int selfId = -1;
+
+    public Set<UUID> players = new HashSet<>();
+}
diff --git a/src/main/java/dev/horizonmc/horizon/replay/Recorder.java b/src/main/java/dev/horizonmc/horizon/replay/Recorder.java
new file mode 100644
index 0000000000000000000000000000000000000000..714a2f5a87b7d9b7f0ddae3ae1d76a403d9589c4
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/replay/Recorder.java
@@ -0,0 +1,264 @@
+package dev.horizonmc.horizon.replay;
+
+import dev.horizonmc.horizon.HorizonLogger;
+import io.netty.channel.local.LocalChannel;
+import net.minecraft.SharedConstants;
+import net.minecraft.core.LayeredRegistryAccess;
+import net.minecraft.core.RegistryAccess;
+import net.minecraft.core.RegistrySynchronization;
+import net.minecraft.network.Connection;
+import net.minecraft.network.ConnectionProtocol;
+import net.minecraft.network.PacketSendListener;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.PacketFlow;
+import net.minecraft.network.protocol.common.ClientboundCustomPayloadPacket;
+import net.minecraft.network.protocol.common.ClientboundDisconnectPacket;
+import net.minecraft.network.protocol.common.ClientboundUpdateTagsPacket;
+import net.minecraft.network.protocol.common.custom.BrandPayload;
+import net.minecraft.network.protocol.configuration.ClientboundFinishConfigurationPacket;
+import net.minecraft.network.protocol.configuration.ClientboundRegistryDataPacket;
+import net.minecraft.network.protocol.configuration.ClientboundUpdateEnabledFeaturesPacket;
+import net.minecraft.network.protocol.game.ClientboundAddEntityPacket;
+import net.minecraft.network.protocol.game.ClientboundBundlePacket;
+import net.minecraft.network.protocol.game.ClientboundGameEventPacket;
+import net.minecraft.network.protocol.game.ClientboundPlayerChatPacket;
+import net.minecraft.network.protocol.game.ClientboundSetTimePacket;
+import net.minecraft.network.protocol.game.ClientboundSystemChatPacket;
+import net.minecraft.network.protocol.login.ClientboundGameProfilePacket;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.RegistryLayer;
+import net.minecraft.tags.TagNetworkSerialization;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.flag.FeatureFlags;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CompletionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
+
+public class Recorder extends Connection {
+
+    private static final HorizonLogger LOGGER = HorizonLogger.LOGGER;
+
+    private final ReplayFile replayFile;
+    private final ServerPhotographer photographer;
+    private final RecorderOption recorderOption;
+    private final RecordMetaData metaData;
+
+    private final ExecutorService saveService = Executors.newSingleThreadExecutor();
+
+    private boolean stopped = false;
+    private boolean paused = false;
+    private boolean resumeOnNextPacket = true;
+
+    private long startTime;
+    private long lastPacket;
+    private long timeShift = 0;
+
+    private boolean isSaved;
+    private boolean isSaving;
+    private ConnectionProtocol state = ConnectionProtocol.LOGIN;
+
+    public Recorder(ServerPhotographer photographer, RecorderOption recorderOption, File replayFile) throws IOException {
+        super(PacketFlow.CLIENTBOUND);
+
+        this.photographer = photographer;
+        this.recorderOption = recorderOption;
+        this.metaData = new RecordMetaData();
+        this.replayFile = new ReplayFile(replayFile);
+        this.channel = new LocalChannel();
+    }
+
+    public void start() {
+        startTime = System.currentTimeMillis();
+
+        metaData.singleplayer = false;
+        metaData.serverName = recorderOption.serverName;
+        metaData.generator = "horizon";
+        metaData.date = startTime;
+        metaData.mcversion = SharedConstants.getCurrentVersion().getName();
+
+        // TODO start event
+        savePacket(new ClientboundGameProfilePacket(photographer.getGameProfile()), ConnectionProtocol.LOGIN);
+        startConfiguration();
+
+        if (recorderOption.forceWeather != null) {
+            setWeather(recorderOption.forceWeather);
+        }
+    }
+
+    public void startConfiguration() {
+        state = ConnectionProtocol.CONFIGURATION;
+        MinecraftServer server = MinecraftServer.getServer();
+        savePacket(new ClientboundCustomPayloadPacket(new BrandPayload(server.getServerModName())), ConnectionProtocol.CONFIGURATION);
+        LayeredRegistryAccess<RegistryLayer> layeredregistryaccess = server.registries();
+
+        savePacket(new ClientboundUpdateEnabledFeaturesPacket(FeatureFlags.REGISTRY.toNames(server.getWorldData().enabledFeatures())), ConnectionProtocol.CONFIGURATION);
+        savePacket(new ClientboundRegistryDataPacket((new RegistryAccess.ImmutableRegistryAccess(RegistrySynchronization.networkedRegistries(layeredregistryaccess))).freeze()), ConnectionProtocol.CONFIGURATION);
+        savePacket(new ClientboundUpdateTagsPacket(TagNetworkSerialization.serializeTagsToNetwork(layeredregistryaccess)), ConnectionProtocol.CONFIGURATION);
+        savePacket(new ClientboundFinishConfigurationPacket(), ConnectionProtocol.CONFIGURATION);
+        state = ConnectionProtocol.PLAY;
+    }
+
+    @Override
+    public void flushChannel() {
+    }
+
+    public void stop() {
+        stopped = true;
+    }
+
+    public void pauseRecording() {
+        resumeOnNextPacket = false;
+        paused = true;
+    }
+
+    public void resumeRecording() {
+        resumeOnNextPacket = true;
+    }
+
+    public void setWeather(RecorderOption.RecordWeather weather) {
+        weather.getPackets().forEach(this::savePacket);
+    }
+
+    public long getRecordedTime() {
+        final long base = System.currentTimeMillis() - startTime;
+        return base - timeShift;
+    }
+
+    private synchronized long getCurrentTimeAndUpdate() {
+        long now = getRecordedTime();
+        if (paused) {
+            if (resumeOnNextPacket) {
+                paused = false;
+            }
+            timeShift = now - lastPacket;
+            return lastPacket;
+        }
+        return lastPacket = now;
+    }
+
+    @Override
+    public boolean isConnected() {
+        return true;
+    }
+
+    @Override
+    public void send(@NotNull Packet<?> packet, @Nullable PacketSendListener callbacks, boolean flush) {
+        if (!stopped) {
+            if (packet instanceof ClientboundBundlePacket packet1) {
+                packet1.subPackets().forEach(subPacket -> {
+                    send(subPacket, null);
+                });
+            }
+
+            if (packet instanceof ClientboundAddEntityPacket packet1) {
+                if (packet1.getType() == EntityType.PLAYER) {
+                    metaData.players.add(packet1.getUUID());
+                    saveMetadata();
+                }
+            }
+
+            if (packet instanceof ClientboundDisconnectPacket) {
+                return;
+            }
+
+            if (recorderOption.forceDayTime != -1 && packet instanceof ClientboundSetTimePacket packet1) {
+                packet = new ClientboundSetTimePacket(packet1.getDayTime(), recorderOption.forceDayTime, false);
+            }
+
+            if (recorderOption.forceWeather != null && packet instanceof ClientboundGameEventPacket packet1) {
+                ClientboundGameEventPacket.Type type = packet1.getEvent();
+                if (type == ClientboundGameEventPacket.START_RAINING || type == ClientboundGameEventPacket.STOP_RAINING || type == ClientboundGameEventPacket.RAIN_LEVEL_CHANGE || type == ClientboundGameEventPacket.THUNDER_LEVEL_CHANGE) {
+                    return;
+                }
+            }
+
+            if (recorderOption.ignoreChat && (packet instanceof ClientboundSystemChatPacket || packet instanceof ClientboundPlayerChatPacket)) {
+                return;
+            }
+
+            savePacket(packet);
+        }
+    }
+
+    private void saveMetadata() {
+        saveService.submit(() -> {
+            try {
+                replayFile.saveMetaData(metaData);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        });
+    }
+
+    private void savePacket(Packet<?> packet) {
+        this.savePacket(packet, state);
+    }
+
+    private void savePacket(Packet<?> packet, final ConnectionProtocol protocol) {
+        try {
+            final long timestamp = getCurrentTimeAndUpdate();
+            saveService.submit(() -> {
+                try {
+                    replayFile.savePacket(timestamp, packet, protocol);
+                } catch (Exception e) {
+                    LOGGER.severe("Error saving packet");
+                    e.printStackTrace();
+                }
+            });
+        } catch (Exception e) {
+            LOGGER.severe("Error saving packet");
+            e.printStackTrace();
+        }
+    }
+
+    public boolean isSaved() {
+        return isSaved;
+    }
+
+    public CompletableFuture<Void> saveRecording(File dest, boolean save) {
+        isSaved = true;
+        if (!isSaving) {
+            isSaving = true;
+            metaData.duration = (int) lastPacket;
+            return CompletableFuture.runAsync(() -> {
+                saveMetadata();
+                saveService.shutdown();
+                boolean interrupted = false;
+                try {
+                    saveService.awaitTermination(10, TimeUnit.SECONDS);
+                } catch (InterruptedException e) {
+                    interrupted = true;
+                }
+                try {
+                    if (save) {
+                        replayFile.closeAndSave(dest);
+                    } else {
+                        replayFile.closeNotSave();
+                    }
+                } catch (IOException e) {
+                    e.printStackTrace();
+                    throw new CompletionException(e);
+                } finally {
+                    if (interrupted) {
+                        Thread.currentThread().interrupt();
+                    }
+                }
+            }, runnable -> {
+                final Thread thread = new Thread(runnable, "Recording file save thread");
+                thread.start();
+            });
+        } else {
+            LOGGER.warning("saveRecording() called twice");
+            return CompletableFuture.supplyAsync(() -> {
+                throw new IllegalStateException("saveRecording() called twice");
+            });
+        }
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/replay/RecorderOption.java b/src/main/java/dev/horizonmc/horizon/replay/RecorderOption.java
new file mode 100644
index 0000000000000000000000000000000000000000..3cb2a7fd4290fe851cf7fa5d22c5d87895106149
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/replay/RecorderOption.java
@@ -0,0 +1,57 @@
+package dev.horizonmc.horizon.replay;
+
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.ClientboundGameEventPacket;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.List;
+
+public class RecorderOption {
+
+    public int recordDistance = -1;
+    public String serverName = "Horizon";
+    public RecordWeather forceWeather = null;
+    public int forceDayTime = -1;
+    public boolean ignoreChat = false;
+    public boolean ignoreItem = false;
+
+    @NotNull
+    @Contract(" -> new")
+    public static RecorderOption createDefaultOption() {
+        return new RecorderOption();
+    }
+
+    @NotNull
+    public static RecorderOption createFromBukkit(@NotNull BukkitRecorderOption bukkitRecorderOption) {
+        RecorderOption recorderOption = new RecorderOption();
+        // recorderOption.recordDistance = bukkitRecorderOption.recordDistance;
+        // recorderOption.ignoreItem = bukkitRecorderOption.ignoreItem;
+        recorderOption.serverName = bukkitRecorderOption.serverName;
+        recorderOption.ignoreChat = bukkitRecorderOption.ignoreChat;
+        recorderOption.forceDayTime = bukkitRecorderOption.forceDayTime;
+        recorderOption.forceWeather = switch (bukkitRecorderOption.forceWeather) {
+            case RAIN -> RecordWeather.RAIN;
+            case CLEAR -> RecordWeather.CLEAR;
+            case THUNDER -> RecordWeather.THUNDER;
+            case NULL -> null;
+        };
+        return recorderOption;
+    }
+
+    public enum RecordWeather {
+        CLEAR(new ClientboundGameEventPacket(ClientboundGameEventPacket.STOP_RAINING, 0), new ClientboundGameEventPacket(ClientboundGameEventPacket.RAIN_LEVEL_CHANGE, 0), new ClientboundGameEventPacket(ClientboundGameEventPacket.THUNDER_LEVEL_CHANGE, 0)),
+        RAIN(new ClientboundGameEventPacket(ClientboundGameEventPacket.START_RAINING, 0), new ClientboundGameEventPacket(ClientboundGameEventPacket.RAIN_LEVEL_CHANGE, 1), new ClientboundGameEventPacket(ClientboundGameEventPacket.THUNDER_LEVEL_CHANGE, 0)),
+        THUNDER(new ClientboundGameEventPacket(ClientboundGameEventPacket.START_RAINING, 0), new ClientboundGameEventPacket(ClientboundGameEventPacket.RAIN_LEVEL_CHANGE, 1), new ClientboundGameEventPacket(ClientboundGameEventPacket.THUNDER_LEVEL_CHANGE, 1));
+
+        private final List<Packet<?>> packets;
+
+        private RecordWeather(Packet<?>... packets) {
+            this.packets = List.of(packets);
+        }
+
+        public List<Packet<?>> getPackets() {
+            return packets;
+        }
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/replay/ReplayFile.java b/src/main/java/dev/horizonmc/horizon/replay/ReplayFile.java
new file mode 100644
index 0000000000000000000000000000000000000000..79ade90e11f5d6a16fc52c8fd0dd5ca906f3d9a6
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/replay/ReplayFile.java
@@ -0,0 +1,178 @@
+package dev.horizonmc.horizon.replay;
+
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import dev.horizonmc.horizon.util.UUIDSerializer;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import net.minecraft.SharedConstants;
+import net.minecraft.network.ConnectionProtocol;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.PacketFlow;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.BufferedOutputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.io.Writer;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.util.List;
+import java.util.UUID;
+import java.util.zip.CRC32;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipOutputStream;
+
+public class ReplayFile {
+
+    private static final String RECORDING_FILE = "recording.tmcpr";
+    private static final String RECORDING_FILE_CRC32 = "recording.tmcpr.crc32";
+    private static final String MARKER_FILE = "markers.json";
+    private static final String META_FILE = "metaData.json";
+
+    private static final Gson MARKER_GSON = new GsonBuilder().registerTypeAdapter(ReplayMarker.class, new ReplayMarker.Serializer()).create();
+    private static final Gson META_GSON = new GsonBuilder().registerTypeAdapter(UUID.class, new UUIDSerializer()).create();
+
+    private final File tmpDir;
+    private final DataOutputStream packetStream;
+    private final CRC32 crc32 = new CRC32();
+
+    private final File markerFile;
+    private final File metaFile;
+
+    public ReplayFile(@NotNull File name) throws IOException {
+        this.tmpDir = new File(name.getParentFile(), name.getName() + ".tmp");
+        if (tmpDir.exists()) {
+            if (!ReplayFile.deleteDir(tmpDir)) {
+                throw new IOException("Recording file " + name + " already exists!");
+            }
+        }
+
+        if (!tmpDir.mkdirs()) {
+            throw new IOException("Failed to create temp directory for recording " + tmpDir);
+        }
+
+        File packetFile = new File(tmpDir, RECORDING_FILE);
+        metaFile = new File(tmpDir, META_FILE);
+        markerFile = new File(tmpDir, MARKER_FILE);
+
+        packetStream = new DataOutputStream(new DigestOutputStream(new BufferedOutputStream(new FileOutputStream(packetFile)), crc32));
+    }
+
+    private byte @NotNull [] getPacketBytes(Packet<?> packet, ConnectionProtocol state) {
+        int packetID = state.codec(PacketFlow.CLIENTBOUND).packetId(packet);
+        ByteBuf buf = Unpooled.buffer();
+        FriendlyByteBuf packetBuf = new FriendlyByteBuf(buf);
+        packetBuf.writeVarInt(packetID);
+        packet.write(packetBuf);
+
+        buf.readerIndex(0);
+        byte[] ret = new byte[buf.readableBytes()];
+        buf.readBytes(ret);
+        buf.release();
+        return ret;
+    }
+
+    public void saveMarkers(List<ReplayMarker> markers) throws IOException {
+        try (Writer writer = new OutputStreamWriter(new FileOutputStream(markerFile), StandardCharsets.UTF_8)) {
+            writer.write(MARKER_GSON.toJson(markers));
+        }
+    }
+
+    public void saveMetaData(@NotNull RecordMetaData data) throws IOException {
+        data.fileFormat = "MCPR";
+        data.fileFormatVersion = RecordMetaData.CURRENT_FILE_FORMAT_VERSION;
+        data.protocol = SharedConstants.getCurrentVersion().getProtocolVersion();
+
+        try (Writer writer = new OutputStreamWriter(new FileOutputStream(metaFile), StandardCharsets.UTF_8)) {
+            writer.write(META_GSON.toJson(data));
+        }
+    }
+
+    public void savePacket(long timestamp, Packet<?> packet, ConnectionProtocol protocol) throws Exception {
+        byte[] data = getPacketBytes(packet, protocol);
+        packetStream.writeInt((int) timestamp);
+        packetStream.writeInt(data.length);
+        packetStream.write(data);
+    }
+
+    public synchronized void closeAndSave(File file) throws IOException {
+        packetStream.close();
+
+        String[] files = tmpDir.list();
+        if (files == null) {
+            return;
+        }
+
+        try (ZipOutputStream os = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(file)))) {
+            for (String fileName : files) {
+                os.putNextEntry(new ZipEntry(fileName));
+                File f = new File(tmpDir, fileName);
+                copy(new FileInputStream(f), os);
+            }
+
+            os.putNextEntry(new ZipEntry(RECORDING_FILE_CRC32));
+            Writer writer = new OutputStreamWriter(os);
+            writer.write(Long.toString(crc32.getValue()));
+            writer.flush();
+        }
+
+        for (String fileName : files) {
+            File f = new File(tmpDir, fileName);
+            Files.delete(f.toPath());
+        }
+        Files.delete(tmpDir.toPath());
+    }
+
+    public synchronized void closeNotSave() throws IOException {
+        packetStream.close();
+
+        String[] files = tmpDir.list();
+        if (files == null) {
+            return;
+        }
+
+        for (String fileName : files) {
+            File f = new File(tmpDir, fileName);
+            Files.delete(f.toPath());
+        }
+        Files.delete(tmpDir.toPath());
+    }
+
+    private void copy(@NotNull InputStream in, OutputStream out) throws IOException {
+        byte[] buffer = new byte[8192];
+        int len;
+        while ((len = in.read(buffer)) > -1) {
+            out.write(buffer, 0, len);
+        }
+        in.close();
+    }
+
+    private static boolean deleteDir(File dir) {
+        if (dir == null || !dir.exists()) {
+            return false;
+        }
+
+        File[] files = dir.listFiles();
+        if (files != null) {
+            for (File file : files) {
+                if (file.isDirectory()) {
+                    deleteDir(file);
+                } else {
+                    if (!file.delete()) {
+                        return false;
+                    }
+                }
+            }
+        }
+
+        return dir.delete();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/horizonmc/horizon/replay/ReplayMarker.java b/src/main/java/dev/horizonmc/horizon/replay/ReplayMarker.java
new file mode 100644
index 0000000000000000000000000000000000000000..34be2e06fa39a049519209031ddacae52e0afb9a
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/replay/ReplayMarker.java
@@ -0,0 +1,43 @@
+package dev.horizonmc.horizon.replay;
+
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonPrimitive;
+import com.google.gson.JsonSerializationContext;
+import com.google.gson.JsonSerializer;
+
+import java.lang.reflect.Type;
+
+public class ReplayMarker {
+
+    public int time;
+    public String name;
+    public double x = 0;
+    public double y = 0;
+    public double z = 0;
+    public float phi = 0;
+    public float theta = 0;
+    public float varphi = 0;
+
+    public static class Serializer implements JsonSerializer<ReplayMarker> {
+        @Override
+        public JsonElement serialize(ReplayMarker src, Type typeOfSrc, JsonSerializationContext context) {
+            JsonObject ret = new JsonObject();
+            JsonObject value = new JsonObject();
+            JsonObject position = new JsonObject();
+            ret.add("realTimestamp", new JsonPrimitive(src.time));
+            ret.add("value", value);
+
+            value.add("name", new JsonPrimitive(src.name));
+            value.add("position", position);
+
+            position.add("x", new JsonPrimitive(src.x));
+            position.add("y", new JsonPrimitive(src.y));
+            position.add("z", new JsonPrimitive(src.z));
+            position.add("yaw", new JsonPrimitive(src.phi));
+            position.add("pitch", new JsonPrimitive(src.theta));
+            position.add("roll", new JsonPrimitive(src.varphi));
+            return ret;
+        }
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/replay/ServerPhotographer.java b/src/main/java/dev/horizonmc/horizon/replay/ServerPhotographer.java
new file mode 100644
index 0000000000000000000000000000000000000000..ee552d0b23c6f6147fdbc043969d82598edd069c
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/replay/ServerPhotographer.java
@@ -0,0 +1,216 @@
+package dev.horizonmc.horizon.replay;
+
+import com.mojang.authlib.GameProfile;
+import dev.horizonmc.horizon.HorizonLogger;
+import dev.horizonmc.horizon.bot.BotStatsCounter;
+import dev.horizonmc.horizon.entity.CraftPhotographer;
+import dev.horizonmc.horizon.entity.Photographer;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ClientInformation;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.stats.ServerStatsCounter;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.level.GameType;
+import net.minecraft.world.phys.Vec3;
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.List;
+import java.util.UUID;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+import static dev.horizonmc.horizon.bot.ServerBot.isCreateLegal;
+
+public class ServerPhotographer extends ServerPlayer {
+
+    private static final List<ServerPhotographer> photographers = new CopyOnWriteArrayList<>();
+
+    public PhotographerCreateState createState;
+    private ServerPlayer followPlayer;
+    private Recorder recorder;
+    private File saveFile;
+    private Vec3 lastPos;
+
+    private final ServerStatsCounter stats;
+
+    private ServerPhotographer(MinecraftServer server, ServerLevel world, GameProfile profile) {
+        super(server, world, profile, ClientInformation.createDefault());
+        this.gameMode = new ServerPhotographerGameMode(this);
+        this.followPlayer = null;
+        this.stats = new BotStatsCounter(server);
+        this.lastPos = this.position();
+    }
+
+    public static ServerPhotographer createPhotographer(@NotNull PhotographerCreateState state) throws IOException {
+        if (!isCreateLegal(state.id)) {
+            return null;
+        }
+
+        MinecraftServer server = MinecraftServer.getServer();
+
+        ServerLevel world = ((CraftWorld) state.loc.getWorld()).getHandle();
+        GameProfile profile = new GameProfile(UUID.randomUUID(), state.id);
+
+        ServerPhotographer photographer = new ServerPhotographer(server, world, profile);
+        photographer.recorder = new Recorder(photographer, state.option, new File("replay", state.id));
+        photographer.saveFile = new File("replay", state.id + ".mcpr");
+        photographer.createState = state;
+
+        photographer.recorder.start();
+        MinecraftServer.getServer().getPlayerList().placeNewPhotographer(photographer.recorder, photographer, world, state.loc);
+        photographer.serverLevel().chunkSource.move(photographer);
+        photographer.setInvisible(true);
+        photographers.add(photographer);
+
+        HorizonLogger.LOGGER.info("Photographer " + state.id + " created");
+
+        // TODO record distance
+
+        return photographer;
+    }
+
+    @Override
+    public void tick() {
+        super.tick();
+        super.doTick();
+
+        if (this.server.getTickCount() % 10 == 0) {
+            connection.resetPosition();
+            this.serverLevel().chunkSource.move(this);
+        }
+
+        if (this.followPlayer != null) {
+            if (this.getCamera() == this || this.getCamera().level() != this.level()) {
+                this.getBukkitPlayer().teleport(this.getCamera().getBukkitEntity().getLocation());
+                this.setCamera(followPlayer);
+            }
+            if (lastPos.distanceToSqr(this.position()) > 1024D) {
+                this.getBukkitPlayer().teleport(this.getCamera().getBukkitEntity().getLocation());
+            }
+        }
+
+        lastPos = this.position();
+    }
+
+    @Override
+    public void die(@NotNull DamageSource damageSource) {
+        super.die(damageSource);
+        remove(true);
+    }
+
+    @Override
+    public boolean isInvulnerableTo(@NotNull DamageSource damageSource) {
+        return true;
+    }
+
+    @Override
+    public boolean hurt(@NotNull DamageSource source, float amount) {
+        return false;
+    }
+
+    @Override
+    public void setHealth(float health) {
+    }
+
+    @NotNull
+    @Override
+    public ServerStatsCounter getStats() {
+        return stats;
+    }
+
+    public void remove(boolean async) {
+        this.remove(async, true);
+    }
+
+    public void remove(boolean async, boolean save) {
+        super.remove(RemovalReason.KILLED);
+        photographers.remove(this);
+        this.recorder.stop();
+        this.server.getPlayerList().removePhotographer(this);
+
+        HorizonLogger.LOGGER.info("Photographer " + createState.id + " removed");
+
+        if (save && !recorder.isSaved()) {
+            CompletableFuture<Void> future = recorder.saveRecording(saveFile, save);
+            if (!async) {
+                future.join();
+            }
+        }
+    }
+
+    public void setFollowPlayer(ServerPlayer followPlayer) {
+        this.setCamera(followPlayer);
+        this.followPlayer = followPlayer;
+    }
+
+    public void setSaveFile(File saveFile) {
+        this.saveFile = saveFile;
+    }
+
+    public void pauseRecording() {
+        this.recorder.pauseRecording();
+    }
+
+    public void resumeRecording() {
+        this.recorder.resumeRecording();
+    }
+
+    public static ServerPhotographer getPhotographer(String id) {
+        for (ServerPhotographer photographer : photographers) {
+            if (photographer.createState.id.equals(id)) {
+                return photographer;
+            }
+        }
+        return null;
+    }
+
+    public static ServerPhotographer getPhotographer(UUID uuid) {
+        for (ServerPhotographer photographer : photographers) {
+            if (photographer.getUUID().equals(uuid)) {
+                return photographer;
+            }
+        }
+        return null;
+    }
+
+    public static List<ServerPhotographer> getPhotographers() {
+        return photographers;
+    }
+
+    public Photographer getBukkitPlayer() {
+        return getBukkitEntity();
+    }
+
+    @Override
+    @NotNull
+    public CraftPhotographer getBukkitEntity() {
+        return (CraftPhotographer) super.getBukkitEntity();
+    }
+
+    public static class PhotographerCreateState {
+
+        public RecorderOption option;
+        public Location loc;
+        public final String id;
+
+        public PhotographerCreateState(Location loc, String id, RecorderOption option) {
+            this.loc = loc;
+            this.id = id;
+            this.option = option;
+        }
+
+        public ServerPhotographer createSync() {
+            try {
+                return createPhotographer(this);
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+            return null;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/dev/horizonmc/horizon/replay/ServerPhotographerGameMode.java b/src/main/java/dev/horizonmc/horizon/replay/ServerPhotographerGameMode.java
new file mode 100644
index 0000000000000000000000000000000000000000..f5a0518f338b40b2d463f751959b42e1b81ecf74
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/replay/ServerPhotographerGameMode.java
@@ -0,0 +1,35 @@
+package dev.horizonmc.horizon.replay;
+
+import net.kyori.adventure.text.Component;
+import net.minecraft.server.level.ServerPlayerGameMode;
+import net.minecraft.world.level.GameType;
+import org.bukkit.event.player.PlayerGameModeChangeEvent;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public class ServerPhotographerGameMode extends ServerPlayerGameMode {
+
+    public ServerPhotographerGameMode(ServerPhotographer photographer) {
+        super(photographer);
+        super.setGameModeForPlayer(GameType.SPECTATOR, null);
+    }
+
+    @Override
+    public boolean changeGameModeForPlayer(@NotNull GameType gameMode) {
+        return false;
+    }
+
+    @Nullable
+    @Override
+    public PlayerGameModeChangeEvent changeGameModeForPlayer(@NotNull GameType gameMode, PlayerGameModeChangeEvent.@NotNull Cause cause, @Nullable Component cancelMessage) {
+        return null;
+    }
+
+    @Override
+    protected void setGameModeForPlayer(@NotNull GameType gameMode, @Nullable GameType previousGameMode) {
+    }
+
+    @Override
+    public void tick() {
+    }
+}
diff --git a/src/main/java/dev/horizonmc/horizon/util/UUIDSerializer.java b/src/main/java/dev/horizonmc/horizon/util/UUIDSerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..509e644a97a4e326cbbac08b1debd601efa0c1d1
--- /dev/null
+++ b/src/main/java/dev/horizonmc/horizon/util/UUIDSerializer.java
@@ -0,0 +1,17 @@
+package dev.horizonmc.horizon.util;
+
+import com.google.gson.JsonElement;
+import com.google.gson.JsonPrimitive;
+import com.google.gson.JsonSerializationContext;
+import com.google.gson.JsonSerializer;
+import org.jetbrains.annotations.NotNull;
+
+import java.lang.reflect.Type;
+import java.util.UUID;
+
+public class UUIDSerializer implements JsonSerializer<UUID> {
+    @Override
+    public JsonElement serialize(@NotNull UUID src, Type typeOfSrc, JsonSerializationContext context) {
+        return new JsonPrimitive(src.toString());
+    }
+}
diff --git a/src/main/java/net/minecraft/commands/arguments/EntityArgument.java b/src/main/java/net/minecraft/commands/arguments/EntityArgument.java
index 8d79cfa371546996ef65f94232c1d344e7c590ec..66bba5167f102bc869f90a6032f1fdd41b611364 100644
--- a/src/main/java/net/minecraft/commands/arguments/EntityArgument.java
+++ b/src/main/java/net/minecraft/commands/arguments/EntityArgument.java
@@ -147,6 +147,7 @@ public class EntityArgument implements ArgumentType<EntitySelector> {
                 if (icompletionprovider instanceof CommandSourceStack commandSourceStack && commandSourceStack.getEntity() instanceof ServerPlayer sourcePlayer) {
                     collection = new java.util.ArrayList<>();
                     for (final ServerPlayer player : commandSourceStack.getServer().getPlayerList().getPlayers()) {
+                        if (player instanceof dev.horizonmc.horizon.replay.ServerPhotographer) continue; // Horizon - skip photographer
                         if (sourcePlayer.getBukkitEntity().canSee(player.getBukkitEntity())) {
                             collection.add(player.getGameProfile().getName());
                         }
diff --git a/src/main/java/net/minecraft/commands/arguments/selector/EntitySelector.java b/src/main/java/net/minecraft/commands/arguments/selector/EntitySelector.java
index fc1bba350030c076405711716e9830f8ae7f3953..2148b0ef4a5184f86c5296d66bc1fac7e47ebacb 100644
--- a/src/main/java/net/minecraft/commands/arguments/selector/EntitySelector.java
+++ b/src/main/java/net/minecraft/commands/arguments/selector/EntitySelector.java
@@ -122,6 +122,7 @@ public class EntitySelector {
             return this.findPlayers(source);
         } else if (this.playerName != null) {
             ServerPlayer entityplayer = source.getServer().getPlayerList().getPlayerByName(this.playerName);
+            entityplayer = entityplayer instanceof dev.horizonmc.horizon.replay.ServerPhotographer ? null : entityplayer; // Horizon - skip photographer
 
             return (List) (entityplayer == null ? Collections.emptyList() : Lists.newArrayList(new ServerPlayer[]{entityplayer}));
         } else if (this.entityUUID != null) {
@@ -137,6 +138,7 @@ public class EntitySelector {
                 ServerLevel worldserver = (ServerLevel) iterator.next();
 
                 entity = worldserver.getEntity(this.entityUUID);
+                entity = entity instanceof dev.horizonmc.horizon.replay.ServerPhotographer ? null : entity; // Horizon - skip photographer
             } while (entity == null);
 
             return Lists.newArrayList(new Entity[]{entity});
@@ -145,7 +147,7 @@ public class EntitySelector {
             Predicate<Entity> predicate = this.getPredicate(vec3d);
 
             if (this.currentEntity) {
-                return (List) (source.getEntity() != null && predicate.test(source.getEntity()) ? Lists.newArrayList(new Entity[]{source.getEntity()}) : Collections.emptyList());
+                return (List) (source.getEntity() != null && !(source.getEntity() instanceof dev.horizonmc.horizon.replay.ServerPhotographer) && predicate.test(source.getEntity()) ? Lists.newArrayList(new Entity[]{source.getEntity()}) : Collections.emptyList()); // Horizon - skip photographer
             } else {
                 List<Entity> list = Lists.newArrayList();
 
@@ -160,6 +162,7 @@ public class EntitySelector {
                         this.addEntities(list, worldserver1, vec3d, predicate);
                     }
                 }
+                list.removeIf(entity -> entity instanceof dev.horizonmc.horizon.replay.ServerPhotographer); // Horizon - skip photographer
 
                 return this.sortAndLimit(vec3d, list);
             }
@@ -200,9 +203,11 @@ public class EntitySelector {
 
         if (this.playerName != null) {
             entityplayer = source.getServer().getPlayerList().getPlayerByName(this.playerName);
+            entityplayer = entityplayer instanceof dev.horizonmc.horizon.replay.ServerPhotographer ? null : entityplayer; // Horizon - skip photographer
             return entityplayer == null || !canSee(source, entityplayer) ? Collections.emptyList() : Lists.newArrayList(entityplayer); // Purpur
         } else if (this.entityUUID != null) {
             entityplayer = source.getServer().getPlayerList().getPlayer(this.entityUUID);
+            entityplayer = entityplayer instanceof dev.horizonmc.horizon.replay.ServerPhotographer ? null : entityplayer; // Horizon - skip photographer
             return entityplayer == null || !canSee(source, entityplayer) ? Collections.emptyList() : Lists.newArrayList(entityplayer); // Purpur
         } else {
             Vec3 vec3d = (Vec3) this.position.apply(source.getPosition());
@@ -214,7 +219,7 @@ public class EntitySelector {
                 if (entity instanceof ServerPlayer) {
                     ServerPlayer entityplayer1 = (ServerPlayer) entity;
 
-                    if (predicate.test(entityplayer1)) {
+                    if (predicate.test(entityplayer1) && !(entityplayer1 instanceof dev.horizonmc.horizon.replay.ServerPhotographer)) { // Horizon - skip photographer
                         return !canSee(source, entityplayer1) ? Collections.emptyList() : Lists.newArrayList(entityplayer1); // Purpur
                     }
                 }
@@ -225,7 +230,7 @@ public class EntitySelector {
                 Object object;
 
                 if (this.isWorldLimited()) {
-                    object = source.getLevel().getPlayers(predicate, i);
+                    object = source.getLevel().getPlayers((entityplayer3 -> !(entityplayer3 instanceof dev.horizonmc.horizon.replay.ServerPhotographer) && predicate.test(entityplayer3)), i); // Horizon - skip photographer
                     ((List) object).removeIf(entityplayer3 -> !canSee(source, (ServerPlayer) entityplayer3)); // Purpur
                 } else {
                     object = Lists.newArrayList();
@@ -234,7 +239,7 @@ public class EntitySelector {
                     while (iterator.hasNext()) {
                         ServerPlayer entityplayer2 = (ServerPlayer) iterator.next();
 
-                        if (predicate.test(entityplayer2) && canSee(source, entityplayer2)) { // Purpur
+                        if (predicate.test(entityplayer2) && !(entityplayer2 instanceof dev.horizonmc.horizon.replay.ServerPhotographer)) { // Horizon - skip photographer
                             ((List) object).add(entityplayer2);
                             if (((List) object).size() >= i) {
                                 return (List) object;
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index c193c62f6adde7720363ebd38bf7fc3bbd92b8e9..e08c0031ab218853f0e2dba9c9024338a52f3783 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -1645,7 +1645,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     private ServerStatus.Players buildPlayerStatus() {
-        List<ServerPlayer> list = this.playerList.getPlayers();
+        List<ServerPlayer> list = this.playerList.realPlayers; // Horizon - only real player
         int i = this.getMaxPlayers();
 
         if (this.hidesOnlinePlayers()) {
diff --git a/src/main/java/net/minecraft/server/PlayerAdvancements.java b/src/main/java/net/minecraft/server/PlayerAdvancements.java
index 2a473e9f3c122ec177754cfef0f4a44d6cba55f2..e1aded8f375956bd83dd7c368275467daff76de7 100644
--- a/src/main/java/net/minecraft/server/PlayerAdvancements.java
+++ b/src/main/java/net/minecraft/server/PlayerAdvancements.java
@@ -226,7 +226,7 @@ public class PlayerAdvancements {
 
     public boolean award(AdvancementHolder advancement, String criterionName) {
         // Horizon start - bot can't get advancement
-        if (player instanceof dev.horizonmc.horizon.bot.ServerBot) {
+        if (player instanceof dev.horizonmc.horizon.bot.ServerBot || player instanceof dev.horizonmc.horizon.replay.ServerPhotographer) { // Horizon - and photographer
             return false;
         }
         // Horizon end - bot can't get advancement
diff --git a/src/main/java/net/minecraft/server/commands/OpCommand.java b/src/main/java/net/minecraft/server/commands/OpCommand.java
index e7b444a10b244828827b3c66c53465206ea8e0ec..54365b54778c3d98e7fd5e68d40406dd8bcb9641 100644
--- a/src/main/java/net/minecraft/server/commands/OpCommand.java
+++ b/src/main/java/net/minecraft/server/commands/OpCommand.java
@@ -24,8 +24,7 @@ public class OpCommand {
                         .suggests(
                             (context, builder) -> {
                                 PlayerList playerList = context.getSource().getServer().getPlayerList();
-                                return SharedSuggestionProvider.suggest(
-                                    playerList.getPlayers()
+                                return SharedSuggestionProvider.suggest(playerList.realPlayers
                                         .stream()
                                         .filter(player -> !playerList.isOp(player.getGameProfile()))
                                         .map(player -> player.getGameProfile().getName()),
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 47c20035d86760d756f56bef0aa307df36cfaeb9..350e6dd283b7a77f4ea788116399496c5ccca72c 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -298,7 +298,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         super(server, connection, clientData, player); // CraftBukkit
         this.chunkSender = new PlayerChunkSender(connection.isMemoryConnection());
         // Horizon start - fakeplayer
-        if (player instanceof dev.horizonmc.horizon.bot.ServerBot) {
+        if (player instanceof dev.horizonmc.horizon.bot.ServerBot || player instanceof dev.horizonmc.horizon.replay.ServerPhotographer) { // Horizon - and photographer
             connection.setListenerForce(this);
         } else {
             connection.setListener(this);
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 1754daa6ffd28fa257b13c3dc7cbbaab815a7ff9..53f7b294b150292734cc5810c33df5d2952f1dbe 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -27,6 +27,7 @@ import javax.annotation.Nullable;
 
 import dev.horizonmc.horizon.HorizonConfig;
 import dev.horizonmc.horizon.bot.ServerBot;
+import dev.horizonmc.horizon.replay.ServerPhotographer;
 import net.minecraft.ChatFormatting;
 import net.minecraft.FileUtil;
 import net.minecraft.commands.CommandSourceStack;
@@ -155,6 +156,7 @@ public abstract class PlayerList {
     private boolean allowCheatsForAllPlayers;
     private static final boolean ALLOW_LOGOUTIVATOR = false;
     private int sendAllPlayerInfoIn;
+    public final List<ServerPlayer> realPlayers = new java.util.concurrent.CopyOnWriteArrayList(); // Horizon - replay api
 
     // CraftBukkit start
     private CraftServer cserver;
@@ -181,6 +183,120 @@ public abstract class PlayerList {
     }
     abstract public void loadAndSaveFiles(); // Paper - fix converting txt to json file; moved from DedicatedPlayerList constructor
 
+    // Leaves start - replay api
+    public void placeNewPhotographer(Connection connection, ServerPhotographer player, ServerLevel worldserver, Location location) {
+        player.isRealPlayer = true; // Paper
+        player.loginTime = System.currentTimeMillis(); // Paper
+
+        ServerLevel worldserver1 = worldserver;
+
+        player.setServerLevel(worldserver1);
+        player.spawnIn(worldserver1);
+        player.gameMode.setLevel((ServerLevel) player.level());
+
+        LevelData worlddata = worldserver1.getLevelData();
+
+        player.loadGameTypes(null);
+        ServerGamePacketListenerImpl playerconnection = new ServerGamePacketListenerImpl(this.server, connection, player, CommonListenerCookie.createInitial(player.gameProfile));
+        GameRules gamerules = worldserver1.getGameRules();
+        boolean flag = gamerules.getBoolean(GameRules.RULE_DO_IMMEDIATE_RESPAWN);
+        boolean flag1 = gamerules.getBoolean(GameRules.RULE_REDUCEDDEBUGINFO);
+        boolean flag2 = gamerules.getBoolean(GameRules.RULE_LIMITED_CRAFTING);
+
+        playerconnection.send(new ClientboundLoginPacket(player.getId(), worlddata.isHardcore(), this.server.levelKeys(), this.getMaxPlayers(), worldserver1.getWorld().getSendViewDistance(), worldserver1.getWorld().getSimulationDistance(), flag1, !flag, flag2, player.createCommonSpawnInfo(worldserver1))); // Paper - replace old player chunk management
+        player.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
+        playerconnection.send(new ClientboundChangeDifficultyPacket(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
+        playerconnection.send(new ClientboundPlayerAbilitiesPacket(player.getAbilities()));
+        playerconnection.send(new ClientboundSetCarriedItemPacket(player.getInventory().selected));
+        playerconnection.send(new ClientboundUpdateRecipesPacket(this.server.getRecipeManager().getRecipes()));
+        this.sendPlayerPermissionLevel(player);
+        player.getStats().markAllDirty();
+        player.getRecipeBook().sendInitialRecipeBook(player);
+        this.updateEntireScoreboard(worldserver1.getScoreboard(), player);
+        this.server.invalidateStatus();
+
+        playerconnection.teleport(player.getX(), player.getY(), player.getZ(), player.getYRot(), player.getXRot());
+        ServerStatus serverping = this.server.getStatus();
+
+        if (serverping != null) {
+            player.sendServerStatus(serverping);
+        }
+
+        this.players.add(player);
+        this.playersByName.put(player.getScoreboardName().toLowerCase(java.util.Locale.ROOT), player); // Spigot
+        this.playersByUUID.put(player.getUUID(), player);
+
+        player.supressTrackerForLogin = true;
+        worldserver1.addNewPlayer(player);
+        this.server.getCustomBossEvents().onPlayerConnect(player);
+        mountSavedVehicle(player, worldserver1, null);
+        CraftPlayer bukkitPlayer = player.getBukkitEntity();
+
+        player.containerMenu.transferTo(player.containerMenu, bukkitPlayer);
+        if (!player.connection.isAcceptingMessages()) {
+            return;
+        }
+
+        dev.horizonmc.horizon.protocol.core.HorizonProtocolManager.handlePlayerJoin(player); // Horizon - protocol
+
+        // Horizon start - bot support
+        if (dev.horizonmc.horizon.HorizonConfig.fakeplayerSupport) {
+            ServerBot bot = ServerBot.getBot(player.getScoreboardName().toLowerCase(java.util.Locale.ROOT));
+            if (bot != null) {
+                bot.die(bot.damageSources().fellOutOfWorld()); // Horizon - remove bot with the same name
+                this.playersByName.put(player.getScoreboardName().toLowerCase(java.util.Locale.ROOT), player);
+                this.playersByUUID.put(player.getUUID(), player);
+            }
+            ServerBot.getBots().forEach(bot1 -> {
+                bot1.sendPlayerInfo(player);
+                bot1.sendFakeDataIfNeed(player, true);
+            }); // Horizon - render bot
+        }
+        // Horizon end - bot support
+
+        final List<ServerPlayer> onlinePlayers = Lists.newArrayListWithExpectedSize(this.players.size() - 1);
+        for (int i = 0; i < this.players.size(); ++i) {
+            ServerPlayer entityplayer1 = this.players.get(i);
+
+            if (entityplayer1 == player || !bukkitPlayer.canSee(entityplayer1.getBukkitEntity())) {
+                continue;
+            }
+
+            onlinePlayers.add(entityplayer1);
+        }
+        if (!onlinePlayers.isEmpty()) {
+            player.connection.send(ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(onlinePlayers, player));
+        }
+
+        player.sentListPacket = true;
+        player.supressTrackerForLogin = false;
+        ((ServerLevel) player.level()).getChunkSource().chunkMap.addEntity(player);
+
+        this.sendLevelInfo(player, worldserver1);
+
+        if (player.level() == worldserver1 && !worldserver1.players().contains(player)) {
+            worldserver1.addNewPlayer(player);
+            this.server.getCustomBossEvents().onPlayerConnect(player);
+        }
+
+        worldserver1 = player.serverLevel();
+        Iterator iterator = player.getActiveEffects().iterator();
+        while (iterator.hasNext()) {
+            MobEffectInstance mobeffect = (MobEffectInstance) iterator.next();
+            playerconnection.send(new ClientboundUpdateMobEffectPacket(player.getId(), mobeffect));
+        }
+
+        if (player.isDeadOrDying()) {
+            net.minecraft.core.Holder<net.minecraft.world.level.biome.Biome> plains = worldserver1.registryAccess().registryOrThrow(net.minecraft.core.registries.Registries.BIOME)
+                    .getHolderOrThrow(net.minecraft.world.level.biome.Biomes.PLAINS);
+            player.connection.send(new net.minecraft.network.protocol.game.ClientboundLevelChunkWithLightPacket(
+                    new net.minecraft.world.level.chunk.EmptyLevelChunk(worldserver1, player.chunkPosition(), plains),
+                    worldserver1.getLightEngine(), (java.util.BitSet) null, (java.util.BitSet) null, false)
+            );
+        }
+    }
+    // Leaves end - replay api
+
     public void placeNewPlayer(Connection connection, ServerPlayer player, CommonListenerCookie clientData) {
         player.isRealPlayer = true; // Paper
         player.loginTime = System.currentTimeMillis(); // Paper - Replace OfflinePlayer#getLastPlayed
@@ -327,6 +443,7 @@ public abstract class PlayerList {
 
         // entityplayer.connection.send(ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(this.players)); // CraftBukkit - replaced with loop below
         this.players.add(player);
+        this.realPlayers.add(player); // Horizon - replay api
         this.playersByName.put(player.getScoreboardName().toLowerCase(java.util.Locale.ROOT), player); // Spigot
         this.playersByUUID.put(player.getUUID(), player);
         // this.broadcastAll(ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(List.of(entityplayer))); // CraftBukkit - replaced with loop below
@@ -398,6 +515,12 @@ public abstract class PlayerList {
                 continue;
             }
 
+            // Horizon start - skip photographer
+            if (entityplayer1 instanceof ServerPhotographer) {
+                continue;
+            }
+            // Horizon end - skip photographer
+
             onlinePlayers.add(entityplayer1); // Paper - Use single player info update packet on join
         }
         // Paper start - Use single player info update packet on join
@@ -613,6 +736,43 @@ public abstract class PlayerList {
 
     }
 
+    // Horizon start - replay mod api
+    public void removePhotographer(ServerPhotographer entityplayer) {
+        ServerLevel worldserver = entityplayer.serverLevel();
+
+        entityplayer.awardStat(Stats.LEAVE_GAME);
+
+        if (entityplayer.containerMenu != entityplayer.inventoryMenu) {
+            entityplayer.closeContainer(org.bukkit.event.inventory.InventoryCloseEvent.Reason.DISCONNECT);
+        }
+
+        if (server.isSameThread()) entityplayer.doTick();
+
+        if (this.collideRuleTeamName != null) {
+            final net.minecraft.world.scores.Scoreboard scoreBoard = this.server.getLevel(Level.OVERWORLD).getScoreboard();
+            final PlayerTeam team = scoreBoard.getPlayersTeam(this.collideRuleTeamName);
+            if (entityplayer.getTeam() == team && team != null) {
+                scoreBoard.removePlayerFromTeam(entityplayer.getScoreboardName(), team);
+            }
+        }
+
+        worldserver.removePlayerImmediately(entityplayer, Entity.RemovalReason.UNLOADED_WITH_PLAYER);
+        entityplayer.retireScheduler();
+        entityplayer.getAdvancements().stopListening();
+        this.players.remove(entityplayer);
+        this.playersByName.remove(entityplayer.getScoreboardName().toLowerCase(java.util.Locale.ROOT));
+        this.server.getCustomBossEvents().onPlayerDisconnect(entityplayer);
+        UUID uuid = entityplayer.getUUID();
+        ServerPlayer entityplayer1 = this.playersByUUID.get(uuid);
+
+        if (entityplayer1 == entityplayer) {
+            this.playersByUUID.remove(uuid);
+        }
+
+        this.cserver.getScoreboardManager().removePlayer(entityplayer.getBukkitEntity());
+    }
+    // Horizon stop - replay mod api
+
     public net.kyori.adventure.text.Component remove(ServerPlayer entityplayer) { // CraftBukkit - return string // Paper - return Component
         // Paper start - Fix kick event leave message not being sent
         return this.remove(entityplayer, net.kyori.adventure.text.Component.translatable("multiplayer.player.left", net.kyori.adventure.text.format.NamedTextColor.YELLOW, io.papermc.paper.configuration.GlobalConfiguration.get().messages.useDisplayNameInQuitMessage ? entityplayer.getBukkitEntity().displayName() : io.papermc.paper.adventure.PaperAdventure.asAdventure(entityplayer.getDisplayName())));
@@ -682,6 +842,7 @@ public abstract class PlayerList {
         entityplayer.retireScheduler(); // Paper - Folia schedulers
         entityplayer.getAdvancements().stopListening();
         this.players.remove(entityplayer);
+        this.realPlayers.remove(entityplayer); // Horizon - replay api
         this.playersByName.remove(entityplayer.getScoreboardName().toLowerCase(java.util.Locale.ROOT)); // Spigot
         this.server.getCustomBossEvents().onPlayerDisconnect(entityplayer);
         UUID uuid = entityplayer.getUUID();
@@ -775,7 +936,7 @@ public abstract class PlayerList {
             event.disallow(PlayerLoginEvent.Result.KICK_BANNED, io.papermc.paper.adventure.PaperAdventure.asAdventure(ichatmutablecomponent)); // Paper - Adventure
         } else {
             // return this.players.size() >= this.maxPlayers && !this.canBypassPlayerLimit(gameprofile) ? IChatBaseComponent.translatable("multiplayer.disconnect.server_full") : null;
-            if (this.players.size() >= this.maxPlayers && !(player.hasPermission("purpur.joinfullserver") || this.canBypassPlayerLimit(gameprofile))) { // Purpur
+            if (this.realPlayers.size() >= this.maxPlayers && !(player.hasPermission("purpur.joinfullserver") || this.canBypassPlayerLimit(gameprofile))) { // Purpur // Horizon
                 event.disallow(PlayerLoginEvent.Result.KICK_FULL, net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(org.spigotmc.SpigotConfig.serverFullMessage)); // Spigot // Paper - Adventure
             }
         }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 7c23153814f032d1cc8f4ec1c05d8e5ea885c7d7..f2df07e4c059b3ae8389b0dc7e5cfe0493560ad8 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -15,6 +15,7 @@ import com.mojang.brigadier.tree.LiteralCommandNode;
 import com.mojang.serialization.Dynamic;
 import com.mojang.serialization.Lifecycle;
 import dev.horizonmc.horizon.entity.CraftBotManager;
+import dev.horizonmc.horizon.entity.CraftPhotographerManager;
 import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
 import java.awt.image.BufferedImage;
 import java.io.ByteArrayOutputStream;
@@ -309,6 +310,7 @@ public final class CraftServer implements Server {
     private final io.papermc.paper.logging.SysoutCatcher sysoutCatcher = new io.papermc.paper.logging.SysoutCatcher(); // Paper
     private final CraftPotionBrewer potionBrewer = new CraftPotionBrewer(); // Paper - Custom Potion Mixes
     private final CraftBotManager botManager = new CraftBotManager();
+    private final CraftPhotographerManager photographerManager = new CraftPhotographerManager();
 
     // Paper start - Folia region threading API
     private final io.papermc.paper.threadedregions.scheduler.FallbackRegionScheduler regionizedScheduler = new io.papermc.paper.threadedregions.scheduler.FallbackRegionScheduler();
@@ -390,7 +392,7 @@ public final class CraftServer implements Server {
     public CraftServer(DedicatedServer console, PlayerList playerList) {
         this.console = console;
         this.playerList = (DedicatedPlayerList) playerList;
-        this.playerView = Collections.unmodifiableList(Lists.transform(playerList.players, new Function<ServerPlayer, CraftPlayer>() {
+        this.playerView = Collections.unmodifiableList(Lists.transform(playerList.realPlayers, new Function<ServerPlayer, CraftPlayer>() { // Horizon - replay api
             @Override
             public CraftPlayer apply(ServerPlayer player) {
                 return player.getBukkitEntity();
@@ -3374,4 +3376,11 @@ public final class CraftServer implements Server {
         return botManager;
     }
     // Horizon end - Bot API
+
+    // Leaves start - replay mod api
+    @Override
+    public CraftPhotographerManager getPhotographerManager() {
+        return photographerManager;
+    }
+    // Leaves end - replay mod api
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index 1ed49a2016ce1a2530d56017753a945725e41e6b..43b46bd8d1cfc119995db13e85d534850942e12e 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -11,6 +11,8 @@ import java.util.UUID;
 
 import dev.horizonmc.horizon.bot.ServerBot;
 import dev.horizonmc.horizon.entity.CraftBot;
+import dev.horizonmc.horizon.entity.CraftPhotographer;
+import dev.horizonmc.horizon.replay.ServerPhotographer;
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.nbt.Tag;
 import net.minecraft.network.chat.Component;
@@ -111,6 +113,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
         }
 
         if (entity instanceof ServerBot) { return new CraftBot(server, (ServerBot) entity); }
+        if (entity instanceof ServerPhotographer) { return new CraftPhotographer(server, (ServerPhotographer) entity); }
 
         // Special case complex part, since there is no extra entity type for them
         if (entity instanceof EnderDragonPart complexPart) {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index fb2d05e43df3bfb72b1f6e325736dd3cbc6c3096..acba5b23e602ac7e6d3a9bc1602734acaab97bdb 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -2147,7 +2147,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
 
     @Override
     public boolean canSee(Player player) {
-        return this.canSee((org.bukkit.entity.Entity) player);
+        return !(player instanceof dev.horizonmc.horizon.entity.Photographer) && this.canSee((org.bukkit.entity.Entity) player); // Horizon - skip photographer
     }
 
     @Override
